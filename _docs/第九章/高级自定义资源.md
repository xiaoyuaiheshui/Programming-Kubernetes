第9章. 高级自定义资源
=====================

在本章中，我们将带您了解有关CR的高级主题：versioning, conversion,和
admission controllers。

对于多个版本，CRD变得更加严重，与基于Golang的API资源的区别也越来越小。当然，与此同时，复杂性在开发和维护以及运营上都大大增加了。我们将这些功能称为"advanced"功能，是因为它们将CRD从清单（即纯粹的声明性）转移到了Golang世界（即，成为了真正的软件开发项目）。

即使您不打算构建自定义API
Server，而是打算直接切换到CRD，我们也强烈建议您不要跳过第8章。advanced
CRD周围的许多概念在自定义API
Server领域都有直接的对应关系，并且受到以下动机的激励。
阅读第8章也将使理解本章更加容易。

可通过GitHub存储库获得此处显示和讨论的所有示例的代码。

Custom Resource Versioning(自定义资源版本控制)
==============================================

在第8章中，我们了解了如何通过不同的API版本使用资源。在自定义API
Server的示例中，匹萨资源同时存在于v1alpha1和v1beta1版本中（请参见"示例：匹萨餐厅"）。在自定义API
Server内部，请求中的每个对象首先从API端点版本转换为内部版本（请参阅\`\`
nternal Types and
Conversion\'\'和图8-5），然后再转换回外部版本以进行存储并转换为内部版本。返回响应。转换机制是由转换功能实现的，其中一些功能是手动编写的，有些是生成的（请参见"Conversions"）。

版本控制API是一种强大的机制，可以在保持与旧客户端的兼容性的同时适应和改进API。版本化在Kubernetes中的每个地方都扮演着核心角色，以将Alpha
API提升为Beta并最终提升为通用（GA）。在此过程中，API通常会更改结构或进行扩展。

长期以来，版本控制是仅可通过第8章中介绍的聚合API
Server使用的功能。任何严重的API最终都需要进行版本控制，因为破坏与API使用者的兼容性是不可接受的。

幸运的是，最近在Kubernetes中添加了CRD的版本控制-Kubernetes
1.14中的alpha版本，并在1.15版本中将其升级为beta版本。请注意，转换需要使用结构化的OpenAPI
v3验证架构（请参见\`\` Validating Custom
Resources\'\'）。无论如何，结构模式基本上是像Kubebuilder这样的工具所产生的。我们将在"Structural
Schemas"中讨论技术细节。

我们将在这里向您展示版本控制的工作原理，因为它将在不久的将来在CR的许多重要应用中发挥核心作用。

Revising the Pizza Restaurant(修改比萨餐厅)
-------------------------------------------

为了了解CR转换的工作原理，我们将重新实现第8章中的披萨餐厅示例，这次仅使用CRD，即不涉及aggregated的API
Server。

为了进行转换，我们将专注于Pizza资源：

> **apiVersion**: restaurant.programming-kubernetes.info/v1alpha1
>
> **kind**: Pizza
>
> **metadata**:
>
> **name**: margherita
>
> **spec**:
>
> **toppings**:
>
> \- mozzarella
>
> \- tomato

此对象在v1beta1版本中应具有不同的配料切片表示形式：

> **apiVersion**: restaurant.programming-kubernetes.info/v1beta1
>
> **kind**: Pizza
>
> **metadata**:
>
> **name**: margherita
>
> **spec**:
>
> **toppings**:
>
> \- **name**: mozzarella
>
> **quantity**: 1
>
> \- **name**: tomato
>
> **quantity**: 1

、

在v1alpha1中，配料的重复用于表示额外的芝士披萨，但在v1beta1中，我们通过为每个配料使用数量字段来做到这一点。配料的顺序无关紧要。

我们要实现这种转换-从v1alpha1转换为v1beta1并返回。
不过，在进行此操作之前，我们先将API定义为CRD。
请注意，我们不能在同一群集中具有aggregated API
server和相同GroupVersion的CRD。
因此，在继续此处的CRD之前，请确保已删除第8章中的APIServices。

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: pizzas.restaurant.programming-kubernetes.info
>
> **spec**:
>
> **group**: restaurant.programming-kubernetes.info
>
> **names**:
>
> **kind**: Pizza
>
> **listKind**: PizzaList
>
> **plural**: pizzas
>
> **singular**: pizza
>
> **scope**: Namespaced
>
> **version**: v1alpha1
>
> **versions**:
>
> \- **name**: v1alpha1
>
> **served**: true
>
> **storage**: true
>
> **schema**: \...
>
> \- **name**: v1beta1
>
> **served**: true
>
> **storage**: false
>
> **schema**: \...

CRD定义了两个版本：v1alpha1和v1beta1。
我们将前者设置为存储版本（请参见图9-1），这意味着要存储在etcd中的每个对象都首先转换为v1alpha1。

![onversion and storage
version](media/image1.png){width="5.763888888888889in"
height="1.9960793963254593in"}

###### *Figure 9-1. Conversion and storage version*

由于CRD是当前定义的，因此我们可以将对象创建为v1alpha1并将其检索为v1beta1，但是两个API端点都返回相同的对象。
这显然不是我们想要的。 但是，我们很快会对此进行改进。

但是在此之前，我们将在群集中设置CRD并创建一个玛格丽塔披萨：

> **apiVersion**: restaurant.programming-kubernetes.info/v1alpha1
>
> **kind**: Pizza
>
> **metadata**:
>
> **name**: margherita
>
> **spec**:
>
> **toppings**:
>
> \- mozzarella
>
> \- tomato

我们注册前面的CRD，然后创建margherita对象：

> \$ kubectl create -f pizza-crd.yaml
>
> \$ kubectl create -f margherita-pizza.yaml

不出所料，我们为两个版本返回了相同的对象：

> \$ kubectl get pizza margherita -o yaml
>
> apiVersion: restaurant.programming-kubernetes.info/v1beta1
>
> kind: Pizza
>
> metadata:
>
> creationTimestamp: \"2019-04-14T11:39:20Z\"
>
> generation: 1
>
> name: margherita
>
> namespace: pizza-apiserver
>
> resourceVersion: \"47959\"
>
> selfLink:
> /apis/restaurant.programming-kubernetes.info/v1beta1/namespaces/pizza-apiserver/
>
> pizzas/margherita
>
> uid: f18427f0-5ea9-11e9-8219-124e4d2dc074
>
> spec:
>
> toppings:
>
> \- mozzarella
>
> \- tomato

Kubernetes使用规范版本顺序； 那是：

v1alpha1

不稳定：可能会消失或随时更改，并且通常默认情况下处于禁用状态。

v1beta1

趋于稳定：至少在与v1平行的一个发行版中存在; 合同：没有不兼容的API更改。

v1

稳定或通用（GA）：将保持良好状态并兼容。

GA版本按此顺序排在第一位，然后是beta，然后是alpha，主要版本从高到低排序，次要版本则相同。
每个不适合此模式的CRD版本都排在最后，按字母顺序排列。

在我们的例子中，尽管创建的对象的版本是v1alpha1，但前面的Kubectl得到披萨，因此返回v1beta1。

Conversion Webhook Architecture（转换Webhook架构）
--------------------------------------------------

现在，让我们添加从v1alpha1到v1beta1的转换，然后再返回。CRD转换是通过Kubernetes中的webhooks实现的。
图9-2显示了流程：

1、client（例如，我们的Kubectl拿披萨玛格丽塔披萨）请求版本。

2\. etcd已经以某种版本存储了对象。

3.如果版本不匹配，则将存储对象发送到Webhook服务器进行转换。
Webhook返回带有已转换对象的响应。

4.转换后的对象被发送回client。

![onversion Webhook](media/image2.png){width="5.763888888888889in"
height="1.212775590551181in"}

###### *Figure 9-2. Conversion webhook*

我们必须实现此Webhook服务器。 在此之前，让我们看一下webhook API。
Kubernetes
API服务器在API组apiextensions.k8s.io/v1beta1中发送一个ConversionReview对象：

> **type** ConversionReview **struct** {
>
> metav1.TypeMeta \`json:\",inline\"\`
>
> Request \*ConversionRequest
>
> Response \*ConversionResponse

}\
在发送到Webhook的有效负载中设置了请求字段。在响应中设置响应字段。

该请求看起来像这样：

> **type** ConversionRequest **struct** {
>
> \...
>
> *// \`desiredAPIVersion\` is the version to convert given objects to.*
>
> *// For example, \"myapi.example.com/v1.\"*
>
> DesiredAPIVersion **string**
>
> *// \`objects\` is the list of CR objects to be converted.*
>
> Objects \[\]runtime.RawExtension
>
> }

DesiredAPIVersion字符串具有我们从TypeMeta知道的常用apiVersion格式：group
/ version。

对象字段具有许多对象。
这是一个切片，因为对于一个披萨列表请求，Webhook将收到一个转换请求，此切片是该列表请求的所有对象。

Webhook转换并设置响应：

> **type** ConversionResponse **struct** {
>
> \...
>
> *// \`convertedObjects\` is the list of converted versions of
> \`request.objects\`*
>
> *// if the \`result\` is successful otherwise empty. The webhook is
> expected to*
>
> *// set apiVersion of these objects to the
> ConversionRequest.desiredAPIVersion.*
>
> *// The list must also have the same size as input list with the same
> objects*
>
> *// in the same order (i.e. equal UIDs and object meta).*
>
> ConvertedObjects \[\]runtime.RawExtension
>
> *// \`result\` contains the result of conversion with extra details if
> the*
>
> *// conversion failed. \`result.status\` determines if the conversion
> failed*
>
> *// or succeeded. The \`result.status\` field is required and
> represents the*
>
> *// success or failure of the conversion. A successful conversion must
> set*
>
> *// \`result.status\` to \`Success\`. A failed conversion must set
> \`result.status\`*
>
> *// to \`Failure\` and provide more details in \`result.message\` and
> return http*
>
> *// status 200. The \`result.message\` will be used to construct an
> error*
>
> *// message for the end user.*
>
> Result metav1.Status
>
> }

结果状态告诉Kubernetes API服务器转换是否成功。

但是，在请求管道中何时真正调用了我们的转换webhook？
我们可以期望什么样的输入对象？
为了更好地理解这一点，请查看图9-3中的常规请求管道：所有这些实心和条纹圆圈都是在k8s.io/apiserver代码中进行转换的地方。

![onversion webhook calls for
CRs](media/image3.png){width="5.763888888888889in"
height="3.3056463254593176in"}

###### *Figure 9-3. Conversion webhook calls for CRs*

与aggregated的自定义API Server（请参阅\`\` Internal Types and
Conversion\'\'）相反，CR不使用内部类型，而是直接在外部API版本之间进行转换。
因此，图9-4中只有那些黄色圆圈实际上在进行转换; 实心圆是CRD的NOOP。
换句话说：CRD转换仅发生在etcd和之间。

![here conversion takes place for
CRs](media/image4.png){width="5.763888888888889in"
height="3.3056463254593176in"}

###### *Figure 9-4. Where conversion takes place for CRs*

因此，我们可以假设将从请求管道中的这两个位置调用webhook（请参阅图9-3）。

还要注意，修补程序请求会在冲突时自动重试（更新无法重试，并且它们会直接向调用方发出错误响应）。
每次重试都包含对etcd的读取和写入（图9-3中的黄色圆圈），因此每次迭代都会导致对Webhook的两次调用。

###### WARNING

在"Conversions"中有关转化重要性的所有警告同样适用于此：转化必须正确。
错误会很快导致数据丢失和API行为不一致。

在我们开始实现Webhook之前，最后要说一下Webhook可以做什么，并且必须避免：

•请求和响应中对象的顺序不得更改。

•除标签和注释外，ObjectMeta不得突变。

•转换为全部或全部为零：要么所有对象都成功转换，要么全部失败。

Conversion Webhook Implementation（转换Webhook实现）
----------------------------------------------------

有了理论基础，我们准备开始实施webhook项目。您可以在存储库中找到源，其中包括：

•作为HTTPS Web服务器的Webhook实现

•多个端点：

♣/ convert / v1beta1 /
pizza可以在v1alpha1和v1beta1之间转换一个披萨对象。

♣/ admit / v1beta1 /
pizza默认将规格字段设置为马苏里拉奶酪，番茄和萨拉米香肠。

♣/ validate / v1beta1 / pizza验证每个指定的配料都有对应的哦诶聊对象。

最后两个端点是准入Webhooks，将在\`\` Admission
Webhooks\'\'中详细讨论。相同的webhook二进制文件将同时用于接纳和转换。

这些路径中的v1beta1不应与我们的餐厅API组的v1beta1混淆，但是它是作为webhook支持的APIextensions.k8s.io
API组版本。某天将支持该Webhook
API的v1，这时我们将添加相应的v1作为另一个端点，以支持旧的（截至今天）和新的Kubernetes集群。可以在CRD清单中指定Webhook支持的版本。

我们来看看这种转换网络钩子是如何工作的。之后，我们将更深入地探讨如何将Webhook部署到真实集群中。再次注意，webhook转换在1.14中仍为Alpha，必须使用CustomResourceWebhookConversion功能门手动启用，但在1.15中可作为beta使用。

Setting Up the HTTPS Server（设置HTTPS Server）
-----------------------------------------------

第一步是启动一个支持传输层安全性或TLS（即HTTPS）的Web服务器。
Kubernetes中的Webhook需要HTTPS。 转换Webhook甚至需要Kubernetes
API服务器针对CRD对象中提供的CA捆绑软件成功检查的证书。

在示例项目中，我们使用了k8s.io/apiserver一部分的安全服务库。
它提供了您可能会习惯于部署kube-apiserver或aggregated API
server二进制文件的所有TLS标志和行为。

k8s.io/apiserver安全服务代码遵循options-config模式（请参阅\`\` Options
and Config Pattern and Startup Plumbing\'\'）。
将代码嵌入到自己的二进制文件中非常容易：

> **func** NewDefaultOptions() \*Options {
>
> o := &Options{
>
> \*options.NewSecureServingOptions(),
>
> }
>
> o.SecureServing.ServerCert.PairName = \"pizza-crd-webhook\"
>
> **return** o
>
> }
>
> **type** Options **struct** {
>
> SecureServing options.SecureServingOptions
>
> }
>
> **type** Config **struct** {
>
> SecureServing \*server.SecureServingInfo
>
> }
>
> **func** (o \*Options) AddFlags(fs \*pflag.FlagSet) {
>
> o.SecureServing.AddFlags(fs)
>
> }
>
> **func** (o \*Options) Config() (\*Config, **error**) {
>
> err := o.SecureServing.MaybeDefaultWithSelfSignedCerts(\"0.0.0.0\",
> **nil**, **nil**)
>
> **if** err != **nil** {
>
> **return** **nil**, err
>
> }
>
> c := &Config{}
>
> **if** err := o.SecureServing.ApplyTo(&c.SecureServing); err !=
> **nil** {
>
> **return** **nil**, err
>
> }
>
> **return** c, **nil**
>
> }

在二进制文件的主要功能中，此Options结构被实例化并连接到标志集：

> opt := NewDefaultOptions()
>
> fs := pflag.NewFlagSet(\"pizza-crd-webhook\", pflag.ExitOnError)
>
> globalflag.AddGlobalFlags(fs, \"pizza-crd-webhook\")
>
> opt.AddFlags(fs)
>
> **if** err := fs.Parse(os.Args); err != **nil** {
>
> panic(err)
>
> }
>
> *// create runtime config*
>
> cfg, err := opt.Config()
>
> **if** err != **nil** {
>
> panic(err)
>
> }
>
> stopCh := server.SetupSignalHandler()
>
> \...
>
> *// run server*
>
> restaurantInformers.Start(stopCh)
>
> **if** doneCh, err := cfg.SecureServing.Serve(
>
> handlers.LoggingHandler(os.Stdout, mux),
>
> time.Second \* 30, stopCh,
>
> ); err != **nil** {
>
> panic(err)
>
> } **else** {
>
> \<-doneCh
>
> }

代替三个点，我们使用以下三个路径来设置HTTP多路复用器：

> *// register handlers*
>
> restaurantInformers := restaurantinformers.NewSharedInformerFactory(
>
> clientset, time.Minute \* 5,
>
> )
>
> mux := http.NewServeMux()
>
> mux.Handle(\"/convert/v1beta1/pizza\",
> http.HandlerFunc(conversion.Serve))
>
> mux.Handle(\"/admit/v1beta1/pizza\",
> http.HandlerFunc(admission.ServePizzaAdmit))
>
> mux.Handle(\"/validate/v1beta1/pizza\",
>
> http.HandlerFunc(admission.ServePizzaValidation(restaurantInformers)))
>
> restaurantInformers.Start(stopCh)

由于路径/ validate / v1beta1 /
pizza上的披萨验证webhook必须知道群集中现有的顶部对象，因此我们为restaurant.programming-kubernetes.info
API组实例化了一个共享通知工厂。

现在我们来看一下conversion.Serve背后的实际转换webhook实现。
这是一个普通的Golang
HTTP处理函数，这意味着它将获取请求和响应编写器作为参数。

请求主体包含来自API组apiextensions.k8s.io/v1beta1的ConversionReview对象。
因此，我们必须首先从请求中读取主体，然后对字节片进行解码。
我们通过使用API Machinery的解串器来实现此目的：

> **func** Serve(w http.ResponseWriter, req \*http.Request) {
>
> *// read body*
>
> body, err := ioutil.ReadAll(req.Body)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to read body: %v\", err))
>
> **return**
>
> }
>
> *// decode body as conversion review*
>
> gv := apiextensionsv1beta1.SchemeGroupVersion
>
> reviewGVK := gv.WithKind(\"ConversionReview\")
>
> obj, gvk, err := codecs.UniversalDeserializer().Decode(body,
> &reviewGVK,
>
> &apiextensionsv1beta1.ConversionReview{})
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to decode body: %v\", err))
>
> **return**
>
> }
>
> review, ok := obj.(\*apiextensionsv1beta1.ConversionReview)
>
> **if** !ok {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected GroupVersionKind: %s\", gvk))
>
> **return**
>
> }
>
> **if** review.Request == **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected nil request\"))
>
> **return**
>
> }
>
> \...
>
> }

此代码使用了从方案派生的编解码器工厂编解码器。该方案必须包含apiextensions.k8s.io/v1beta1的类型。我们还添加了餐厅API组的类型。
传递的ConversionReview对象将在运行时内嵌入我们的披萨类型。RawExtension类型。

首先，让我们创建方案和编解码器工厂：

> **import** (
>
> apiextensionsv1beta1
> \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1\"
>
> \"github.com/programming-kubernetes/pizza-crd/pkg/apis/restaurant/install\"
>
> \...
>
> )
>
> **var** (
>
> scheme = runtime.NewScheme()
>
> codecs = serializer.NewCodecFactory(scheme)
>
> )
>
> **func** init() {
>
> utilruntime.Must(apiextensionsv1beta1.AddToScheme(scheme))
>
> install.Install(scheme)
>
> }

runtime.RawExtension是包装在另一个对象字段中的类似Kubernetes的对象的包装。它的结构实际上非常简单：

> **type** RawExtension **struct** {
>
> *// Raw is the underlying serialization of this object.*
>
> Raw \[\]**byte** \`protobuf:\"bytes,1,opt,name=raw\"\`
>
> *// Object can hold a representation of this extension - useful for
> working*
>
> *// with versioned structs.*
>
> Object Object \`json:\"-\"\`
>
> }

此外，runtime.RawExtension具有特殊的JSON和protobuf封送处理两种方法。
此外，在转换为内部类型时（即自动编码和解码），在向运行时对象的转换过程中存在特殊的逻辑。

在CRD的情况下，我们没有内部类型，因此转换魔术不起作用。
仅向RawExtension.Raw填充发送到Webhook进行转换的Pizza对象的JSON字节片。
因此，我们将不得不解码该字节片。
再次注意，一个ConversionReview可能包含许多对象，因此我们必须遍历所有对象：

> *// convert objects*
>
> review.Response = &apiextensionsv1beta1.ConversionResponse{
>
> UID: review.Request.UID,
>
> Result: metav1.Status{
>
> Status: metav1.StatusSuccess,
>
> },
>
> }
>
> **var** objs \[\]runtime.Object
>
> **for** \_, in := **range** review.Request.Objects {
>
> **if** in.Object == **nil** {
>
> **var** err **error**
>
> in.Object, \_, err = codecs.UniversalDeserializer().Decode(
>
> in.Raw, **nil**, **nil**,
>
> )
>
> **if** err != **nil** {
>
> review.Response.Result = metav1.Status{
>
> Message: err.Error(),
>
> Status: metav1.StatusFailure,
>
> }
>
> **break**
>
> }
>
> }
>
> obj, err := convert(in.Object, review.Request.DesiredAPIVersion)
>
> **if** err != **nil** {
>
> review.Response.Result = metav1.Status{
>
> Message: err.Error(),
>
> Status: metav1.StatusFailure,
>
> }
>
> **break**
>
> }
>
> objs = append(objs, obj)
>
> }

convert调用将实际的in.Object转换，将所需的API版本作为目标版本。
请注意，在发生第一个错误时，我们会立即中断循环。

最后，我们在ConversionReview对象中设置\`\`响应\'\'字段，并使用API
Machinery的响应编写器将其写回为请求的响应正文，该响应编写器再次使用我们的编解码器工厂创建序列化器：

> **if** review.Response.Result.Status == metav1.StatusSuccess {
>
> **for** \_, obj = **range** objs {
>
> review.Response.ConvertedObjects =
>
> append(review.Response.ConvertedObjects,
>
> runtime.RawExtension{Object: obj},
>
> )
>
> }
>
> }
>
> *// write negotiated response*
>
> responsewriters.WriteObject(
>
> http.StatusOK, gvk.GroupVersion(), codecs, review, w, req,
>
> )

现在，我们必须实现实际的披萨转换。
经过以上所有这些工作之后，转换算法才是最简单的部分。
它只是检查我们是否确实获得了已知版本的披萨对象，然后执行从v1beta1到v1alpha1的转换，反之亦然：

> **func** convert(in runtime.Object, apiVersion **string**)
> (runtime.Object, **error**) {
>
> **switch** in := in.(**type**) {
>
> **case** \*v1alpha1.Pizza:
>
> **if** apiVersion != v1beta1.SchemeGroupVersion.String() {
>
> **return** **nil**, fmt.Errorf(\"cannot convert %s to %s\",
>
> v1alpha1.SchemeGroupVersion, apiVersion)
>
> }
>
> klog.V(2).Infof(\"Converting %s/%s from %s to %s\", in.Namespace,
> in.Name,
>
> v1alpha1.SchemeGroupVersion, apiVersion)
>
> out := &v1beta1.Pizza{
>
> TypeMeta: in.TypeMeta,
>
> ObjectMeta: in.ObjectMeta,
>
> Status: v1beta1.PizzaStatus{
>
> Cost: in.Status.Cost,
>
> },
>
> }
>
> out.TypeMeta.APIVersion = apiVersion
>
> idx := **map**\[**string**\]**int**{}
>
> **for** \_, top := **range** in.Spec.Toppings {
>
> **if** i, duplicate := idx\[top\]; duplicate {
>
> out.Spec.Toppings\[i\].Quantity++
>
> **continue**
>
> }
>
> idx\[top\] = len(out.Spec.Toppings)
>
> out.Spec.Toppings = append(out.Spec.Toppings, v1beta1.PizzaTopping{
>
> Name: top,
>
> Quantity: 1,
>
> })
>
> }
>
> **return** out, **nil**
>
> **case** \*v1beta1.Pizza:
>
> **if** apiVersion != v1alpha1.SchemeGroupVersion.String() {
>
> **return** **nil**, fmt.Errorf(\"cannot convert %s to %s\",
>
> v1beta1.SchemeGroupVersion, apiVersion)
>
> }
>
> klog.V(2).Infof(\"Converting %s/%s from %s to %s\",
>
> in.Namespace, in.Name, v1alpha1.SchemeGroupVersion, apiVersion)
>
> out := &v1alpha1.Pizza{
>
> TypeMeta: in.TypeMeta,
>
> ObjectMeta: in.ObjectMeta,
>
> Status: v1alpha1.PizzaStatus{
>
> Cost: in.Status.Cost,
>
> },
>
> }
>
> out.TypeMeta.APIVersion = apiVersion
>
> **for** i := **range** in.Spec.Toppings {
>
> **for** j := 0; j \< in.Spec.Toppings\[i\].Quantity; j++ {
>
> out.Spec.Toppings = append(
>
> out.Spec.Toppings, in.Spec.Toppings\[i\].Name)
>
> }
>
> }
>
> **return** out, **nil**
>
> **default**:
>
> }
>
> klog.V(2).Infof(\"Unknown type %T\", in)
>
> **return** **nil**, fmt.Errorf(\"unknown type %T\", in)
>
> }

请注意，在转换的两个方向上，我们只复制TypeMeta和ObjectMeta，将API版本更改为所需的版本，然后转换toppings切片，这实际上是对象结构上唯一不同的部分。

如果有更多版本，则必须在它们之间进行另一种双向转换。
当然，也可以选择使用集线器版本（如 aggregated API
servers的版本）（请参阅\`\` Internal Types and
Conversion\'\'），而不是实现所有受支持的外部版本之间的转换。

Deploying the Conversion Webhook
--------------------------------

我们现在要部署转换webhook。 您可以在GitHub上找到所有清单。

CRD的转换webhook在集群中启动，并放置在服务对象的后面，该服务对象由CRD清单中的转换webhook规范引用：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: pizzas.restaurant.programming-kubernetes.info
>
> **spec**:
>
> \...
>
> conversion:
>
> **strategy**: Webhook
>
> **webhookClientConfig**:
>
> **caBundle**: *BASE64-CA-BUNDLE*
>
> **service**:
>
> **namespace**: pizza-crd
>
> **name**: webhook
>
> **path**: /convert/v1beta1/pizza

CA捆绑软件必须与Webhook使用的服务证书匹配。
在示例项目中，我们使用Makefile通过OpenSSL生成证书，然后使用文本替换将其插入清单中。

请注意，此处的Kubernetes API Server假定Webhook支持所有指定版本的CRD。
每个CRD只能有一个这样的Webhook。
但是，由于CRD和转换Webhooks通常是由同一团队拥有的，因此这就足够了。

另请注意，当前apiextensions.k8s.io/v1beta1 API中的服务端口必须为443。
该服务可以将其映射到webhook容器使用的任何端口。
在我们的示例中，我们将443映射到8443，由webhook二进制文件提供服务。

Seeing Conversion in Action
---------------------------

现在，我们了解了转换Webhook的工作原理以及如何将其连接到集群中，让我们来看看它的作用。

我们假设您已经checkout了示例项目。
此外，我们假设您有一个启用了Webhook转换的群集（通过1.14群集中的功能门或通过1.15+群集（默认情况下启用了Webhook转换））。
获得此类集群的一种方法是通过kind项目，该项目提供对Kubernetes
1.14.1的支持以及本地kind-config.yaml文件，以启用Alpha功能门进行Webhook转换（\`\`对Kubernetes编程意味着什么？\'\'
开发集群的其他选项数量）：

> **kind**: Cluster
>
> **apiVersion**: kind.sigs.k8s.io/v1alpha3
>
> **kubeadmConfigPatchesJson6902**:
>
> \- **group**: kubeadm.k8s.io
>
> **version**: v1beta1
>
> **kind**: ClusterConfiguration
>
> **patch**: \|
>
> \- op: add
>
> path: /apiServer/extraArgs
>
> value: {}
>
> \- op: add
>
> path: /apiServer/extraArgs/feature-gates
>
> value: CustomResourceWebhookConversion=true

然后我们可以创建一个集群：

> \$ kind create cluster \--image kindest/node-images:v1.14.1 \--config
> kind-config.yaml
>
> \$ export KUBECONFIG=\"**\$(**kind get kubeconfig-path
> \--name=\"kind\"**)**\"

现在我们可以部署了：

> \$ cd pizza-crd
>
> \$ cd manifest/deployment
>
> \$ make
>
> \$ kubectl create -f ns.yaml
>
> \$ kubectl create -f pizza-crd.yaml
>
> \$ kubectl create -f topping-crd.yaml
>
> \$ kubectl create -f sa.yaml
>
> \$ kubectl create -f rbac.yaml
>
> \$ kubectl create -f rbac-bind.yaml
>
> \$ kubectl create -f service.yaml
>
> \$ kubectl create -f serving-cert-secret.yaml
>
> \$ kubectl create -f deployment.yaml

这些清单包含以下文件：

ns.yaml

创建pizza-crd命名空间。

pizza-crd.yaml

在restaurant.programming-kubernetes.info
API组中指定披萨资源，具有v1alpha1和v1beta1版本以及webhook转换配置。

topping-crd.yaml

在同一API组中指定浇头CR，但仅在v1alpha1版本中。

sa.yaml

介绍Webhook服务帐户。

rbac.yaml

定义读取，列出和watch配料的角色。

rbac-bind.yaml

将先前的RBAC角色绑定到Webhook服务帐户。

service.yaml

定义webhook服务，将端口443映射到webhook容器的8443。

serving-cert-secret.yaml

包含webhook容器要使用的服务证书和私钥。
该证书还直接用作前面的披萨CRD清单中的CA捆绑包。

deployment.yaml

启动webhook
pod，传递\--tls-cert-file文件和\--tls-private-key服务证书密钥。

之后，我们可以创建玛格丽塔披萨：

> \$ cat ../examples/margherita-pizza.yaml
>
> apiVersion: restaurant.programming-kubernetes.info/v1alpha1
>
> kind: Pizza
>
> metadata:
>
> name: margherita
>
> spec:
>
> toppings:
>
> \- mozzarella
>
> \- tomato
>
> \$ kubectl create ../examples/margherita-pizza.yaml
>
> pizza.restaurant.programming-kubernetes.info/margherita created

现在，有了转换webhook，我们可以在两个版本中检索相同的对象。
首先在v1alpha1版本中明确：

> \$ kubectl get pizzas.v1alpha1.restaurant.programming-kubernetes.info
> **\\**
>
> margherita -o yaml
>
> apiVersion: restaurant.programming-kubernetes.info/v1alpha1
>
> kind: Pizza
>
> metadata:
>
> creationTimestamp: \"2019-04-14T21:41:39Z\"
>
> generation: 1
>
> name: margherita
>
> namespace: pizza-crd
>
> resourceVersion: \"18296\"
>
> pizzas/margherita
>
> uid: 15c1c06a-5efe-11e9-9230-0242f24ba99c
>
> spec:
>
> toppings:
>
> \- mozzarella
>
> \- tomato
>
> status: {}

然后与v1beta1相同的对象显示了不同的配料结构：

> \$ kubectl get pizzas.v1beta1.restaurant.programming-kubernetes.info
> **\\**
>
> margherita -o yaml
>
> apiVersion: restaurant.programming-kubernetes.info/v1beta1
>
> kind: Pizza
>
> metadata:
>
> creationTimestamp: \"2019-04-14T21:41:39Z\"
>
> generation: 1
>
> name: margherita
>
> namespace: pizza-crd
>
> resourceVersion: \"18296\"
>
> pizzas/margherita
>
> uid: 15c1c06a-5efe-11e9-9230-0242f24ba99c
>
> spec:
>
> toppings:
>
> \- name: mozzarella
>
> quantity: 1
>
> \- name: tomato
>
> quantity: 1
>
> status: {}

同时，在webhook pod的日志中，我们看到此转换调用：

> I0414 21:46:28.639707 1 convert.go:35\] Converting
> pizza-crd/margherita
>
> from restaurant.programming-kubernetes.info/v1alpha1
>
> to restaurant.programming-kubernetes.info/v1beta1
>
> 10.32.0.1 - - \[14/Apr/2019:21:46:28 +0000\]
>
> \"POST /convert/v1beta1/pizza?timeout=30s HTTP/2.0\" 200 968

因此，webhook正在按预期方式工作。

Admission Webhooks
==================

在\`\` Use Cases for Custom API Servers\'\'中，我们讨论了使用aggregated
API server比使用CR更好的选择的用例。
给出的许多原因是可以自由使用Golang来实现某些行为，而不是局限于CRD清单中的声明性功能。

在上一节中，我们已经了解了Golang如何用于构建CRD转换webhooks。
同样，在Golang中，使用类似的机制向CRD添加自定义许可。

基本上，我们与aggregated API
server中的自定义准入插件具有相同的自由度（请参阅\`\`
Admission\'\'）：存在mutating和validating准入Webhook，它们在与本机资源相同的位置被调用，如图9所示。

![dmission in the CR request
pipeline](media/image5.png){width="5.763888888888889in"
height="3.3056463254593176in"}

###### *Figure 9-5. Admission in the CR request pipeline*

我们在\`\` Validating Custom Resources\'\'中看到了基于OpenAPI的CRD验证。
在图9-5中，在标有\`\`验证\'\'的框中进行验证。
在此之后，将调用验证接纳webhooks，在此之前调用变异接纳webhooks。

准入网络钩子几乎在准入插件顺序的末尾，即配额之前。
入场webhooks在Kubernetes 1.14中是beta版本，因此在大多数集群中都可用。

###### TIP

对于准入webhooks API的v1，计划最多允许两次通过准入链。
这意味着较早的准入插件或Webhook在一定程度上可以取决于较晚的插件或Webhook的输出。因此，将来这种机制将变得更加强大。

Admission Requirements in the Restaurant Example
------------------------------------------------

餐馆示例将admission用于多个方面：

•spec.toppings默认为零或无干酪，番茄和萨拉米香肠。

•未知字段应从CR JSON中删除，而不应保留在etcd中。

•spec.toppings必须仅包含具有相应配料对象的配料。

前两个用例是mutating。 第三个用例纯粹是在验证。
因此，我们将使用一个变异Webhook和一个验证Webhook来实现这些步骤。

###### NOTE

通过OpenAPI v3验证架构进行本地默认设置的工作正在进行中。
OpenAPI有一个默认字段，API Server将在将来应用它。
此外，删除未知字段将成为每种资源的标准行为，由Kubernetes API
Server通过称为修剪的机制来完成。

修剪在Kubernetes 1.15中作为beta提供。 计划在1.16中提供默认的beta版本。
当目标集群中两个功能均可用时，可以实现之前列表中的两个用例，而无需任何webhook。

Admission Webhook Architecture
------------------------------

Admission webhooks与我们在本章前面看到的conversion
webhooks挂钩在结构上非常相似。

它们被部署在集群中，在服务映射端口443后面到Pod的某个端口的后面，并使用API组admission.k8s.io/v1beta1中的检查对象AdmissionReview进行调用：

> \-\--
>
> *// AdmissionReview describes an admission review request/response.*
>
> **type** AdmissionReview **struct** {
>
> metav1.TypeMeta \`json:\",inline\"\`
>
> *// Request describes the attributes for the admission request.*
>
> *// +optional*
>
> Request \*AdmissionRequest \`json:\"request,omitempty\"\`
>
> *// Response describes the attributes for the admission response.*
>
> *// +optional*
>
> Response \*AdmissionResponse \`json:\"response,omitempty\"\`
>
> }
>
> \-\--

"
AdmissionRequest"包含我们习惯于使用的所有信息（请参见"Implementation"）：

> *// AdmissionRequest describes the admission.Attributes for the
> admission request.*
>
> **type** AdmissionRequest **struct** {
>
> *// UID is an identifier for the individual request/response. It
> allows us to*
>
> *// distinguish instances of requests which are otherwise identical
> (parallel*
>
> *// requests, requests when earlier requests did not modify etc). The
> UID is*
>
> *// meant to track the round trip (request/response) between the KAS
> and the*
>
> *// WebHook, not the user request. It is suitable for correlating log
> entries*
>
> *// between the webhook and apiserver, for either auditing or
> debugging.*
>
> UID types.UID \`json:\"uid\"\`
>
> *// Kind is the type of object being manipulated. For example: Pod*
>
> Kind metav1.GroupVersionKind \`json:\"kind\"\`
>
> *// Resource is the name of the resource being requested. This is not
> the*
>
> *// kind. For example: pods*
>
> Resource metav1.GroupVersionResource \`json:\"resource\"\`
>
> *// SubResource is the name of the subresource being requested. This
> is a*
>
> *// different resource, scoped to the parent resource, but it may have
> a*
>
> *// different kind. For instance, /pods has the resource \"pods\" and
> the kind*
>
> *// \"Pod\", while /pods/foo/status has the resource \"pods\", the sub
> resource*
>
> *// \"status\", and the kind \"Pod\" (because status operates on
> pods). The*
>
> *// binding resource for a pod though may be /pods/foo/binding, which
> has*
>
> *// resource \"pods\", subresource \"binding\", and kind \"Binding\".*
>
> *// +optional*
>
> SubResource **string** \`json:\"subResource,omitempty\"\`
>
> *// Name is the name of the object as presented in the request. On a
> CREATE*
>
> *// operation, the client may omit name and rely on the server to
> generate*
>
> *// the name. If that is the case, this method will return the empty
> string.*
>
> *// +optional*
>
> Name **string** \`json:\"name,omitempty\"\`
>
> *// Namespace is the namespace associated with the request (if any).*
>
> *// +optional*
>
> Namespace **string** \`json:\"namespace,omitempty\"\`
>
> *// Operation is the operation being performed*
>
> Operation Operation \`json:\"operation\"\`
>
> *// UserInfo is information about the requesting user*
>
> UserInfo authenticationv1.UserInfo \`json:\"userInfo\"\`
>
> *// Object is the object from the incoming request prior to default
> values*
>
> *// being applied*
>
> *// +optional*
>
> Object runtime.RawExtension \`json:\"object,omitempty\"\`
>
> *// OldObject is the existing object. Only populated for UPDATE
> requests.*
>
> *// +optional*
>
> OldObject runtime.RawExtension \`json:\"oldObject,omitempty\"\`
>
> *// DryRun indicates that modifications will definitely not be
> persisted*
>
> *// for this request.*
>
> *// Defaults to false.*
>
> *// +optional*
>
> DryRun \***bool** \`json:\"dryRun,omitempty\"\`
>
> }

相同的AdmissionReview对象用于变异和验证准入Webhook。唯一的区别在于，在变异的情况下，AdmissionResponse可以具有一个字段patch和patchType，该字段在收到Webhook响应后将在Kubernetes
API Server内部应用。在验证的情况下，这两个字段在响应时保持为空。

对于我们而言，最重要的字段是\`\`对象\'\'字段，与前面的转换webhook中一样，它使用runtime.RawExtension类型存储披萨对象。

我们还获得了用于更新请求的旧对象，并且可以说，检查是否为只读但在请求中更改的字段。在我们的示例中，我们不在此做。但是在Kubernetes中，您会遇到很多实现了这种逻辑的情况，例如，对于Pod的大多数字段，因为Pod创建后就无法更改其命令。

在Kubernetes
1.14中，由变异的Webhook返回的补丁必须是JSON补丁类型（请参阅RFC
6902）。此补丁描述了如何修改对象以实现所需的不变性。

请注意，最佳实践是至少在最后验证一个验证Webhook中的每个变异Webhook更改，除非这些强制属性对于该行s为很重要。想象一下其他一些变异的Webhook触及对象中的相同字段。然后，您无法确定变异更改是否会保留到变异接纳链的末端。

除字母顺序外，目前mutating
webhooks中没有其他顺序。目前正在进行讨论，以期将来以一种或另一种方式改变这种情况。

显然，对于验证webhooks的顺序并不重要，Kubernetes API
Server甚至并行调用验证webhooks以减少延迟。相比之下，mutating
的Webhook会给通过它们的每个请求增加延迟，因为它们被顺序调用。

常见延迟（当然很大程度上取决于环境）大约为100毫秒。因此，按顺序运行许多Webhook会导致用户在创建或更新对象时会遇到很大的延迟。

Registering Admission Webhooks
------------------------------

Admission webhooks未在CRD清单中注册。
原因是它们不仅适用于CRD，而且适用于任何类型的资源。
您甚至可以将自定义admission webhooks添加到标准Kubernetes资源。

而是有注册对象：MutingWebhookRegistration和ValidationWebhookRegistration。
它们仅在种类名称上有所不同：

> **apiVersion**: admissionregistration.k8s.io/v1beta1
>
> **kind**: MutatingWebhookConfiguration
>
> **metadata**:
>
> **name**: restaurant.programming-kubernetes.info
>
> **webhooks**:
>
> \- **name**: restaurant.programming-kubernetes.info
>
> **failurePolicy**: Fail
>
> **sideEffects**: None
>
> **admissionReviewVersions**:
>
> \- v1beta1
>
> **rules**:
>
> \- **apiGroups**:
>
> \- \"restaurant.programming-kubernetes.info\"
>
> **apiVersions**:
>
> \- v1alpha1
>
> \- v1beta1
>
> **operations**:
>
> \- CREATE
>
> \- UPDATE
>
> **resources**:
>
> \- pizzas
>
> **clientConfig**:
>
> **service**:
>
> **namespace**: pizza-crd
>
> **name**: webhook
>
> **path**: /admit/v1beta1/pizza
>
> **caBundle**: *CA-BUNDLE*

这将从本章开始注册我们的pizza-crd
webhook，以使我们两个版本的资源pizza，API组restaurant.programming-kubernetes.info以及HTTP动词CREATE和UPDATE（也包括补丁）的许可突变。
。

webhook配置中还有其他方法来限制匹配的资源-例如，名称空间选择器（以排除例如控制平面名称空间以避免引导问题）以及带有通配符和子资源的更高级的资源模式。

最后但并非最不重要的是一种失败模式，可以是失败或忽略。
它指定了如果无法连接Webhook或由于其他原因而失败的操作。

###### WARNING

如果以错误的方式部署集群，Admission webhooks可能会破坏集群。
接纳webhook匹配的核心类型可能会使整个集群无法运行。
对于非CRD资源，必须格外小心地admission webhooks。

具体地说，优良作法是将控制平面和Webhook资源本身从Webhook中排除。

Implementing an Admission Webhook
---------------------------------

通过本章开头我们对转换网络挂钩所做的工作，添加准入功能并不难。
我们还看到路径/ admit / v1beta1 / pizza和/ validate / v1beta1 /
pizza已在pizza-crd-webhook二进制文件的主要功能中注册：

> mux.Handle(\"/admit/v1beta1/pizza\",
> http.HandlerFunc(admission.ServePizzaAdmit))
>
> mux.Handle(\"/validate/v1beta1/pizza\", http.HandlerFunc(
>
> admission.ServePizzaValidation(restaurantInformers)))

这两个HTTP处理程序实现的第一部分看起来几乎与转换webhook相同：

> **func** ServePizzaAdmit(w http.ResponseWriter, req \*http.Request) {
>
> *// read body*
>
> body, err := ioutil.ReadAll(req.Body)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to read body: %v\", err))
>
> **return**
>
> }
>
> *// decode body as admission review*
>
> reviewGVK :=
> admissionv1beta1.SchemeGroupVersion.WithKind(\"AdmissionReview\")
>
> decoder := codecs.UniversalDeserializer()
>
> into := &admissionv1beta1.AdmissionReview{}
>
> obj, gvk, err := decoder.Decode(body, &reviewGVK, into)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to decode body: %v\", err))
>
> **return**
>
> }
>
> review, ok := obj.(\*admissionv1beta1.AdmissionReview)
>
> **if** !ok {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected GroupVersionKind: %s\", gvk))
>
> **return**
>
> }
>
> **if** review.Request == **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected nil request\"))
>
> **return**
>
> }
>
> \...
>
> }

在验证Webhook的情况下，我们必须连接informer（用于检查集群中是否存在配料）。只要informer未同步，我们就会返回内部错误。
未同步的informer的数据不完整，因此馅料可能是未知的，尽管有效，但披萨将被拒绝：

> **func** ServePizzaValidation(informers
> restaurantinformers.SharedInformerFactory)
>
> **func** (http.ResponseWriter, \*http.Request)
>
> {
>
> toppingInformer :=
> informers.Restaurant().V1alpha1().Toppings().Informer()
>
> toppingLister := informers.Restaurant().V1alpha1().Toppings().Lister()
>
> **return** **func**(w http.ResponseWriter, req \*http.Request) {
>
> **if** !toppingInformer.HasSynced() {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"informers not ready\"))
>
> **return**
>
> }
>
> *// read body*
>
> body, err := ioutil.ReadAll(req.Body)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to read body: %v\", err))
>
> **return**
>
> }
>
> *// decode body as admission review*
>
> gv := admissionv1beta1.SchemeGroupVersion
>
> reviewGVK := gv.WithKind(\"AdmissionReview\")
>
> obj, gvk, err := codecs.UniversalDeserializer().Decode(body,
> &reviewGVK,
>
> &admissionv1beta1.AdmissionReview{})
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to decode body: %v\", err))
>
> **return**
>
> }
>
> review, ok := obj.(\*admissionv1beta1.AdmissionReview)
>
> **if** !ok {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected GroupVersionKind: %s\", gvk))
>
> **return**
>
> }
>
> **if** review.Request == **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected nil request\"))
>
> **return**
>
> }
>
> \...
>
> }
>
> }

与在webhook转换案例中一样，我们使用准入API组和饭店API组来设置方案和编解码器工厂：

> **var** (
>
> scheme = runtime.NewScheme()
>
> codecs = serializer.NewCodecFactory(scheme)
>
> )
>
> **func** init() {
>
> utilruntime.Must(admissionv1beta1.AddToScheme(scheme))
>
> install.Install(scheme)
>
> }

通过这两个，我们从AdmissionReview解码嵌入式披萨对象（这次只有一个，没有切片）

> *// decode object*
>
> **if** review.Request.Object.Object == **nil** {
>
> **var** err **error**
>
> review.Request.Object.Object, \_, err =
>
> codecs.UniversalDeserializer().Decode(review.Request.Object.Raw,
> **nil**, **nil**)
>
> **if** err != **nil** {
>
> review.Response.Result = &metav1.Status{
>
> Message: err.Error(),
>
> Status: metav1.StatusFailure,
>
> }
>
> responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),
>
> codecs, review, w, req)
>
> **return**
>
> }
>
> }

然后我们可以进行实际的mutating
admission（两个API版本的spec.toppings默认）：

> orig := review.Request.Object.Raw
>
> **var** bs \[\]**byte**
>
> **switch** pizza := review.Request.Object.Object.(**type**) {
>
> **case** \*v1alpha1.Pizza:
>
> *// default toppings*
>
> **if** len(pizza.Spec.Toppings) == 0 {
>
> pizza.Spec.Toppings = \[\]**string**{\"tomato\", \"mozzarella\",
> \"salami\"}
>
> }
>
> bs, err = json.Marshal(pizza)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf\"unexpected encoding error: %v\", err))
>
> **return**
>
> }
>
> **case** \*v1beta1.Pizza:
>
> *// default toppings*
>
> **if** len(pizza.Spec.Toppings) == 0 {
>
> pizza.Spec.Toppings = \[\]v1beta1.PizzaTopping{
>
> {\"tomato\", 1},
>
> {\"mozzarella\", 1},
>
> {\"salami\", 1},
>
> }
>
> }
>
> bs, err = json.Marshal(pizza)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected encoding error: %v\", err))
>
> **return**
>
> }
>
> **default**:
>
> review.Response.Result = &metav1.Status{
>
> Message: fmt.Sprintf(\"unexpected type %T\",
> review.Request.Object.Object),
>
> Status: metav1.StatusFailure,
>
> }
>
> responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),
>
> codecs, review, w, req)
>
> **return**
>
> }

或者，我们可以使用转换Webhook中的转换算法，然后仅对其中一个版本实施默认设置。
两种方法都是可行的，哪种方法更有意义取决于上下文。
在这里，默认设置非常简单，足以实现两次。

最后一步是计算补丁-原始对象（作为JSON存储在orig中）与新的默认对象之间的差异：

> *// compare original and defaulted version*
>
> ops, err := jsonpatch.CreatePatch(orig, bs)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected diff error: %v\", err))
>
> **return**
>
> }
>
> review.Response.Patch, err = json.Marshal(ops)
>
> **if** err != **nil** {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"unexpected patch encoding error: %v\", err))
>
> **return**
>
> }
>
> typ := admissionv1beta1.PatchTypeJSONPatch
>
> review.Response.PatchType = &typ
>
> review.Response.Allowed = **true**

我们使用JSON-Patch库（Matt
Baird的关键修补程序的一个分支）从原始对象orig和修改后的对象bs派生补丁，二者均以JSON字节片形式传递。
另外，我们可以直接对未类型化的JSON数据进行操作，并手动创建JSON-Patch。
同样，这取决于上下文。 使用差异库很方便。

然后，就像在webhook转换中一样，我们使用先前创建的编解码器工厂将响应写入响应编写器来结束：

> responsewriters.WriteObject(
>
> http.StatusOK, gvk.GroupVersion(), codecs, review, w, req,
>
> )

验证webhook非常相似，但是它使用共享通知者中的toppings列表程序来检查topping对象的存在：

> **switch** pizza := review.Request.Object.Object.(**type**) {
>
> **case** \*v1alpha1.Pizza:
>
> **for** \_, topping := **range** pizza.Spec.Toppings {
>
> \_, err := toppingLister.Get(topping)
>
> **if** err != **nil** && !errors.IsNotFound(err) {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to lookup topping %q: %v\", topping, err))
>
> **return**
>
> } **else** **if** errors.IsNotFound(err) {
>
> review.Response.Result = &metav1.Status{
>
> Message: fmt.Sprintf(\"topping %q not known\", topping),
>
> Status: metav1.StatusFailure,
>
> }
>
> responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),
>
> codecs, review, w, req)
>
> **return**
>
> }
>
> }
>
> review.Response.Allowed = **true**
>
> **case** \*v1beta1.Pizza:
>
> **for** \_, topping := **range** pizza.Spec.Toppings {
>
> \_, err := toppingLister.Get(topping.Name)
>
> **if** err != **nil** && !errors.IsNotFound(err) {
>
> responsewriters.InternalError(w, req,
>
> fmt.Errorf(\"failed to lookup topping %q: %v\", topping, err))
>
> **return**
>
> } **else** **if** errors.IsNotFound(err) {
>
> review.Response.Result = &metav1.Status{
>
> Message: fmt.Sprintf(\"topping %q not known\", topping),
>
> Status: metav1.StatusFailure,
>
> }
>
> responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),
>
> codecs, review, w, req)
>
> **return**
>
> }
>
> }
>
> review.Response.Allowed = **true**
>
> **default**:
>
> review.Response.Result = &metav1.Status{
>
> Message: fmt.Sprintf(\"unexpected type %T\",
> review.Request.Object.Object),
>
> Status: metav1.StatusFailure,
>
> }
>
> }
>
> responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),
>
> codecs, review, w, req)

Admission Webhook in Action
---------------------------

我们通过在集群中创建两个注册对象来部署两个admission webhooks：

> \$ kubectl create -f validatingadmissionregistration.yaml
>
> \$ kubectl create -f mutatingadmissionregistration.yaml

此后，我们将无法再创建配料未知的比萨饼：

> \$ kubectl create -f ../examples/margherita-pizza.yaml
>
> Error from server: error when creating
> \"../examples/margherita-pizza.yaml\":
>
> admission webhook \"restaurant.programming-kubernetes.info\" denied
> the request:
>
> topping \"tomato\" not known

同时，在webhook日志中，我们看到：

> I0414 22:45:46.873541 1 pizzamutation.go:115\] Defaulting pizza-crd/
> in
>
> version admission.k8s.io/v1beta1, Kind=AdmissionReview
>
> 10.32.0.1 - - \[14/Apr/2019:22:45:46 +0000\]
>
> \"POST /admit/v1beta1/pizza?timeout=30s HTTP/2.0\" 200 871
>
> 10.32.0.1 - - \[14/Apr/2019:22:45:46 +0000\]
>
> \"POST /validate/v1beta1/pizza?timeout=30s HTTP/2.0\" 200 956

在示例文件夹中创建配料后，我们可以再次创建玛格丽塔披萨：

> \$ kubectl create -f ../examples/topping-tomato.yaml
>
> \$ kubectl create -f ../examples/topping-salami.yaml
>
> \$ kubectl create -f ../examples/topping-mozzarella.yaml
>
> \$ kubectl create -f ../examples/margherita-pizza.yaml
>
> pizza.restaurant.programming-kubernetes.info/margherita created

最后但并非最不重要的一点，让我们检查默认设置是否按预期工作。
我们要创建一个空的比萨饼：

> **apiVersion**: restaurant.programming-kubernetes.info/v1alpha1
>
> **kind**: Pizza
>
> **metadata**:
>
> **name**: salami
>
> **spec**:

这应该默认为萨拉米香肠披萨，它是：

> \$ kubectl create -f ../examples/empty-pizza.yaml
>
> pizza.restaurant.programming-kubernetes.info/salami created
>
> \$ kubectl get pizza salami -o yaml
>
> apiVersion: restaurant.programming-kubernetes.info/v1beta1
>
> kind: Pizza
>
> metadata:
>
> creationTimestamp: \"2019-04-14T22:49:40Z\"
>
> generation: 1
>
> name: salami
>
> namespace: pizza-crd
>
> resourceVersion: \"23227\"
>
> uid: 962e2dda-5f07-11e9-9230-0242f24ba99c
>
> spec:
>
> toppings:
>
> \- name: tomato
>
> quantity: 1
>
> \- name: mozzarella
>
> quantity: 1
>
> \- name: salami
>
> quantity: 1
>
> status: {}

一种意式香肠比萨，具有我们期望的所有配料。 请享用！

在结束本章之前，我们想了解CRD的apiextensions.k8s.io/v1
API组版本（即，非beta版本，通用可用性），即结构化架构的引入。

Structural Schemas and the Future of CustomResourceDefinitions
==============================================================

从Kubernetes 1.15开始，OpenAPI v3验证模式（请参阅\`\` Validating Custom
Resources\'\'）在CRD方面发挥了越来越重要的作用，因为如果使用以下任何新功能，则必须指定一个模式：

•CRD转换（请参阅图9-2）

• Pruning（请参阅"Pruning Versus Preserving Unknown Fields"）

• Defaulting（请参见"Default Values"）

•OpenAPI架构发布

严格来说，模式的定义仍然是可选的，每个现有的CRD都将继续工作，但是如果没有模式，则CRD将从任何新功能中排除。

此外，在遵守Kubernetes
API约定的意义上，指定的架构必须遵循某些规则以强制指定的类型实际上是理智的。
我们称这些结构图式。

Structural Schemas
------------------

结构化架构是遵守以下规则的OpenAPI v3验证架构（请参见\`\` Validating
Custom Resources\'\'）：

1.该架构为根，对象节点的每个指定字段（通过OpenAPI的属性或附加属性）以及数组节点中的每个项（通过OpenAPI的项目）指定一个非空类型（通过OpenAPI的类型），
除了：

•带有x-kubernetes-int-or-string的节点：true

•具有x-kubernetes-preserve-unknown-fields的节点：true

2.对于在allOf，anyOf，oneOf或not内设置的对象中的每个字段和数组中的每个项目，模式还指定了这些逻辑连接器之外的字段/项目。

3.除x-kubernetes-int-or-string的两种模式外，该架构未在allOf，anyOf，oneOf或not中设置描述，类型，默认值，additionProperties或nullable，除了x-kubernetes-int-or-string的两种模式：true（请参阅"
IntOrString和RawExtensions"）。

4.如果指定了元数据，则仅允许对元数据。名称和元数据。生成名称进行限制。

> 这是一个非结构性的示例：\
> **properties**:
>
> **foo**:
>
> **pattern**: \"abc\"
>
> **metadata**:
>
> **type**: object
>
> **properties**:
>
> **name**:
>
> **type**: string
>
> **pattern**: \"\^a\"
>
> **finalizers**:
>
> **type**: array
>
> **items**:
>
> **type**: string
>
> **pattern**: \"my-finalizer\"
>
> **anyOf**:
>
> \- **properties**:
>
> **bar**:
>
> **type**: integer
>
> **minimum**: 42
>
> **required**: \[\"bar\"\]
>
> **description**: \"foo bar object\"

由于存在以下违规，因此它不是结构化架构：

•根类型丢失（规则1）。

•缺少foo类型（规则1）。

•anyOf内部的bar不在外部指定（规则2）。

•bar的类型在anyOf（规则3）之内。

•说明在anyOf（规则3）中设置。

•不得限制metas.finalizer（规则4）。

相反，以下对应的架构是结构化的：

> **type**: object
>
> **description**: \"foo bar object\"
>
> **properties**:
>
> **foo**:
>
> **type**: string
>
> **pattern**: \"abc\"
>
> **bar**:
>
> **type**: integer
>
> **metadata**:
>
> **type**: object
>
> **properties**:
>
> **name**:
>
> **type**: string
>
> **pattern**: \"\^a\"
>
> **anyOf**:
>
> \- **properties**:
>
> **bar**:
>
> **minimum**: 42
>
> **required**: \[\"bar\"\]

在CRD的非结构条件中报告了违反结构模式规则的情况。

亲自验证"Validating Custom Resources"中的cnat示例的架构和pizza
CRD示例中的架构确实是结构化的。

Pruning Versus Preserving Unknown Fields
----------------------------------------

CRD通常会像在etcd中一样存储任何（可能经过验证的）JSON。
这意味着将保留未指定的字段（如果有一个OpenAPI v3验证模式）。
这与像Pod这样的本地Kubernetes资源形成对比。
如果用户指定了一个字段spec.randomField，API服务器HTTPS端点将接受此字段，但在将该pod写入etcd之前将其删除（我们称其为修剪）。

如果定义了结构化的OpenAPI
v3验证模式（在全局spec.validation.openAPIV3Schema中或对于每个版本），我们可以通过将spec.preserveUnknownFields设置为false来启用修剪（在创建和更新时删除未指定的字段）。

让我们看一下cnat示例.2有了Kubernetes 1.15集群，我们启用了pruning功能：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: ats.cnat.programming-kubernetes.info
>
> **spec**:
>
> \...
>
> preserveUnknownFields: false

然后，我们尝试创建一个具有未知字段的实例：

> **apiVersion**: cnat.programming-kubernetes.info/v1alpha1
>
> **kind**: At
>
> **metadata**:
>
> **name**: example-at
>
> **spec**:
>
> **schedule**: \"2019-07-03T02:00:00Z\"
>
> **command**: echo \"Hello, world!\"
>
> **someGarbage**: 42

如果我们使用Kubectl在example-at检索此对象，则会看到someGarbage值被删除：

> **apiVersion**: cnat.programming-kubernetes.info/v1alpha1
>
> **kind**: At
>
> **metadata**:
>
> **name**: example-at
>
> **spec**:
>
> **schedule**: \"2019-07-03T02:00:00Z\"
>
> **command**: echo \"Hello, world!\"

我们说一些垃圾已经被pruned了。

从Kubernetes 1.15开始，pruned在apiextensions /
v1beta1中可用，但默认为关闭;
也就是说，spec.preserveUnknownFields默认为true。 在apiextensions /
v1中，将不允许创建带有spec.preserveUnknownFields：true的新CRD。

Controlling Pruning
-------------------

在CRD中使用spec.preserveUnknownField：false，为该类型和所有版本的所有CR启用pruned。
但是，可以在OpenAPI
v3验证模式中通过x-kubernetes-preserve-unknown-fields：true来选择不pruning
JSON子树：

> **type**: object
>
> **properties**:
>
> **json**:
>
> **x-kubernetes-preserve-unknown-fields**: true

字段json可以存储任何JSON值，而无需pruned任何内容。

可以部分指定允许的JSON：

> **type**: object
>
> **properties**:
>
> **json**:
>
> **x-kubernetes-preserve-unknown-fields**: true
>
> **type**: object
>
> **description**: this is arbitrary JSON

使用这种方法，仅允许对象类型值。

再次为每个指定的属性（或其他属性）启用pruned：

> **type**: object
>
> **properties**:
>
> **json**:
>
> **x-kubernetes-preserve-unknown-fields**: true
>
> **type**: object
>
> **properties**:
>
> **spec**:
>
> **type**: object
>
> **properties**:
>
> **foo**:
>
> **type**: string
>
> **bar**:
>
> **type**: string

这样，值：

> **json**:
>
> **spec**:
>
> **foo**: abc
>
> **bar**: def
>
> **something**: x
>
> **status**:
>
> **something**: x

将被pruned为：

> **json**:
>
> **spec**:
>
> **foo**: abc
>
> **bar**: def
>
> **status**:
>
> **something**: x

这意味着pruned指定规范对象中的内容字段（因为指定了"规范"），但外部的所有内容均未删除。
未指定状态，因此不会pruned status.something。

IntOrString and RawExtensions
-----------------------------

在某些情况下结构模式不能充分表达。
其中之一是多态字段-可以是不同类型的字段。我们从本地Kubernetes
API类型知道IntOrString。

可以在架构内部使用x-kubernetes-int-or-string：true指令在CRD中使用IntOrString。同样，可以使用x-kubernetes-embedded-object：true声明runtime.RawExtensions。

例如：

> **type**: object
>
> **properties**:
>
> **intorstr**:
>
> **type**: object
>
> **x-kubernetes-int-or-string**: true
>
> **embedded**:
>
> **x-kubernetes-embedded-object**: true
>
> **x-kubernetes-preserve-unknown-fields**: true

这声明：

•名为intorstr的字段，其中包含整数或字符串

•称为嵌入式的字段，其中包含类似Kubernetes的对象，例如完整的pod规范

有关这些指令的所有详细信息，请参阅《官方CRD文档》。

我们要讨论的最后一个取决于结构模式的主题是默认设置。

Default Values
--------------

在本地Kubernetes类型中，通常会默认某些值。
对于CRD，过去只能通过更改admission
webhooks来实现默认设置（请参阅"admission webhooks"）。
但是，从Kubernetes 1.15开始，默认支持直接通过上一节中所述的OpenAPI
v3模式添加到CRD（请参阅设计文档）。

###### NOTE

从1.15版本开始，它仍然是Alpha功能，这意味着默认情况下在功能门CustomResourceDefaulting之后将其禁用。
但是随着beta的升级，大概在1.16，它将在CRD中无处不在。

为了默认某些字段，只需通过OpenAPI
v3架构中的default关键字指定默认值即可。
当您向类型添加新字段时，这非常有用。

从"Validating Custom
Resources"中的cnat示例架构开始，假设我们要使容器图像可自定义，但默认为busybox图像。
为此，我们将字符串类型的image字段添加到OpenAPI
v3模式中，并将默认值设置为busybox：

> **type**: object
>
> **properties**:
>
> **apiVersion**:
>
> **type**: string
>
> **kind**:
>
> **type**: string
>
> **metadata**:
>
> **type**: object
>
> **spec**:
>
> **type**: object
>
> **properties**:
>
> **schedule**:
>
> **type**: string
>
> **pattern**:
> \"\^\\d{4}-(\[0\]\\d\|1\[0-2\])-(\[0-2\]\\d\|3\[01\])\...\"
>
> **command**:
>
> **type**: string
>
> **image**:
>
> **type**: string
>
> **default**: \"busybox\"
>
> **required**:
>
> \- schedule
>
> \- command
>
> **status**:
>
> **type**: object
>
> **properties**:
>
> **phase**:
>
> **type**: string
>
> **required**:
>
> \- metadata
>
> \- apiVersion
>
> \- kind
>
> \- spec

如果用户创建实例时未指定镜像，则将自动设置该值：

> **apiVersion**: cnat.programming-kubernetes.info/v1alpha1
>
> **kind**: At
>
> **metadata**:
>
> **name**: example-at
>
> **spec**:
>
> **schedule**: \"2019-07-03T02:00:00Z\"
>
> **command**: echo \"hello world!\"

创建后，它将自动变为：

> **apiVersion**: cnat.programming-kubernetes.info/v1alpha1
>
> **kind**: At
>
> **metadata**:
>
> **name**: example-at
>
> **spec**:
>
> **schedule**: \"2019-07-03T02:00:00Z\"
>
> **command**: echo \"hello world!\"
>
> **image**: busybox

这看起来超级方便，并显着改善了CRD的用户体验。
而且，从API服务器读取后，保留在etcd中的所有旧对象将自动继承新字段.3

请注意，etcd中的持久对象将不会被重写（即自动迁移）。
换句话说，在读取时，默认值仅动态添加，并且仅在由于其他原因更新对象时才保留。

Summary
=======

Admission和conversion
Webhook使CRD达到了完全不同的水平。在使用这些功能之前，CR通常用于较小而不太严重的用例，通常用于配置和API兼容性不是那么重要的内部应用程序。

使用webhooks，CR看起来更像是本地资源，具有较长的生命周期和强大的语义。我们已经看到了如何实现不同资源之间的依赖关系以及如何设置字段的默认值。

在这一点上，您可能对如何在现有CRD中使用这些功能有很多想法。我们很好奇，将来会基于这些功能看到社区的创新。

计划在Kubernetes
1.16中将1个apiextensions.k8s.io和admissionregistration.k8s.io都升级到v1。

2由于前者的结构简单，因此我们使用cnat示例而不是披萨示例-例如，只有一个版本。当然，所有这些都可以扩展到多个版本（即一个架构版本）。

3例如，通过Kubectl get ats -o yaml。

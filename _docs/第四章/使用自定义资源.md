第四章. 使用自定义资源
======================

在本章中，我们向您介绍自定义资源（CR），这是整个Kubernetes生态系统使用的中央扩展机制之一。

自定义资源用于小型内部配置对象，而没有任何相应的控制器逻辑-完全以声明方式定义。
但是自定义资源在Kubernetes之上的许多严肃的开发项目中也起着核心作用，这些项目希望提供Kubernetes原生API体验。
示例包括Istio，Linkerd 2.0和AWS App
Mesh等服务网格，它们全部都具有自定义资源。

还记得第1章中的"A Motivational Example"吗？
它的核心是一个看起来像这样的CR：

> **apiVersion**: cnat.programming-kubernetes.info/v1alpha1
>
> **kind**: At
>
> **metadata**:
>
> **name**: example-at
>
> **spec**:
>
> **schedule**: \"2019-07-03T02:00:00Z\"
>
> **status**:
>
> **phase**: \"pending\"

自1.7版以来，每个Kubernetes集群中都提供自定义资源。它们与主要的Kubernetes
API资源存储在相同的etcd实例中，并由相同的Kubernetes API Server提供服务。
如图4-1所示，请求都不属于apiextensions-apiserver，如果它们都不是以下两种情况，则它会通过CRD服务定义的资源：

•由聚合的API Server处理（请参阅第8章）。

•本机Kubernetes资源。

![PI Extensions API server inside of the Kubernetes API
server](media/image1.png){width="5.763888888888889in"
height="2.8332283464566927in"}

###### *图4-1. Kubernetes API服务器内部的API*

CustomResourceDefinition（CRD）是Kubernetes资源本身。它描述了群集中的可用CR。
对于前面的示例CR，相应的CRD如下所示：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: ats.cnat.programming-kubernetes.info
>
> **spec**:
>
> **group**: cnat.programming-kubernetes.info
>
> **names**:
>
> **kind**: At
>
> **listKind**: AtList
>
> **plural**: ats
>
> **singular**: at
>
> **scope**: Namespaced
>
> **subresources**:
>
> **status**: {}
>
> **version**: v1alpha1
>
> **versions**:
>
> \- **name**: v1alpha1
>
> **served**: true
>
> **storage**: true

CRD的名称-在这种情况下为ats.cnat.programming-kubernetes.info-必须与复数名称和组名匹配。它在API组cnat.programming-kubernetes.info中的At
CR类型定义为名为ats的命名空间资源。

如果在群集中创建此CRD，则Kubectl将自动检测资源，用户可以通过以下方式访问它：

> \$ kubectl get ats
>
> NAME CREATED AT
>
> ats.cnat.programming-kubernetes.info 2019-04-01T14:03:33Z

Discovery Information
=====================

在后台，kubectl使用来自API服务器的发现information来查找有关新资源的信息。让我们更深入地了解这种发现机制。

在增加Kubectl的详细程度之后，我们实际上可以看到它如何了解新的资源类型。

> \$ kubectl get ats -v=7
>
> \... GET
> https://XXX.eks.amazonaws.com/apis/cnat.programming-kubernetes.info/
>
> v1alpha1/namespaces/cnat/ats?limit=500
>
> \... Request Headers:
>
> \... Accept:
> application/json;as=Table;v=v1beta1;g=meta.k8s.io,application/json
>
> User-Agent: kubectl/v1.14.0 (darwin/amd64) kubernetes/641856d
>
> \... Response Status: 200 OK in 607 milliseconds
>
> NAME AGE
>
> example-at 43s

详细的发现步骤为：

1.最初，kubectl不了解at。

2.因此，kubectl通过/ apis发现端点向API服务器询问所有现有的API组。

3.接下来，kubectl通过/ apis /
group版本组发现端点向API服务器询问所有现有API组中的资源。

4.然后，kubectl将给定类型ats转换为以下形式的三组：

•group（此处为cnat.programming-kubernetes.info）

•version（此处为v1alpha1）

•resource（此处为ats）。

发现端点在最后一步中提供了所有必要的信息来进行转换：

> \$ http localhost:8080/apis/
>
> {
>
> \"groups\": \[{
>
> \"name\": \"at.cnat.programming-kubernetes.info\",
>
> \"preferredVersion\": {
>
> \"groupVersion\": \"cnat.programming-kubernetes.info/v1\",
>
> \"version\": \"v1alpha1"
>
> },
>
> \"versions\": \[{
>
> \"groupVersion\": \"cnat.programming-kubernetes.info/v1alpha1\",
>
> \"version\": \"v1alpha1\"
>
> }\]
>
> }, \...\]
>
> }
>
> \$ http localhost:8080/apis/cnat.programming-kubernetes.info/v1alpha1
>
> {
>
> \"apiVersion\": \"v1\",
>
> \"groupVersion\": \"cnat.programming-kubernetes.info/v1alpha1\",
>
> \"kind\": \"APIResourceList\",
>
> \"resources\": \[{
>
> \"kind\": \"At\",
>
> \"name\": \"ats\",
>
> \"namespaced\": true,
>
> \"verbs\": \[\"create\", \"delete\", \"deletecollection\",
>
> \"get\", \"list\", \"patch\", \"update\", \"watch\"
>
> \]
>
> }, \...\]
>
> }

这全部由发现RESTMapper实现。 我们还在\`\`REST
Mapping\'\'中看到了这种非常常见的RESTMapper类型。

###### 警告

Kubectl CLI还在〜/
.kubectl中维护资源类型的缓存，因此它不必在每次访问时都重新获取发现信息。此缓存每10分钟失效一次。
因此，最多10分钟后，CRD中的更改可能会显示在相应用户的CLI中。

类型定义
========

现在，让我们更详细地看一下CRD和提供的功能：例如在CNat示例中，CRD是Kubernetes API服务器进程内部apiextensions-apiserver提供的apiextensions.k8s.io/v1beta1 API组中的Kubernetes资源。
=================================================================================================================================================================================

CRD的架构如下所示：
===================

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: *name*
>
> **spec**:
>
> **group**: *group name*
>
> **version**: *version name*
>
> **names**:
>
> **kind**: *uppercase name*
>
> **plural**: *lowercase plural name*
>
> **singular**: *lowercase singular name* *\# defaulted to be lowercase
> kind*
>
> **shortNames**: *list of strings as short names* *\# optional*
>
> **listKind**: *uppercase list kind* *\# defaulted to be kindList*
>
> **categories**: *list of category membership like \"all\"* *\#
> optional*
>
> **validation**: *\# optional*
>
> **openAPIV3Schema**: *OpenAPI schema* *\# optional*
>
> **subresources**: *\# optional*
>
> **status**: {} *\# to enable the status subresource (optional)*
>
> **scale**: *\# optional*
>
> **specReplicasPath**: *JSON path for the replica number in the spec of
> the*
>
> *custom resource*
>
> **statusReplicasPath**: *JSON path for the replica number in the
> status of*
>
> *the custom resource*
>
> **labelSelectorPath**: *JSON path of the Scale.Status.Selector field
> in the*
>
> *scale resource*
>
> **versions**: *\# defaulted to the Spec.Version field*
>
> \- **name**: *version name*
>
> **served**: *boolean whether the version is served by the API server*
> *\# defaults to false*
>
> **storage**: *boolean whether this version is the version used to
> store object*
>
> \- \...

许多字段是可选的或默认的。 我们将在以下各节中更详细地说明这些字段。
===================================================================

创建CRD对象后，kube-apiserver内部的apiextensions-apiserver将检查名称并确定它们是否与其他资源冲突或它们本身是否一致。 稍后，它将以CRD的状态报告结果，例如：
==========================================================================================================================================================

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: ats.cnat.programming-kubernetes.info
>
> **spec**:
>
> **group**: cnat.programming-kubernetes.info
>
> **names**:
>
> **kind**: At
>
> **listKind**: AtList
>
> **plural**: ats
>
> **singular**: at
>
> **scope**: Namespaced
>
> **subresources**:
>
> **status**: {}
>
> **validation**:
>
> **openAPIV3Schema**:
>
> **type**: object
>
> **properties**:
>
> **apiVersion**:
>
> **type**: string
>
> **kind**:
>
> **type**: string
>
> **metadata**:
>
> **type**: object
>
> **spec**:
>
> **properties**:
>
> **schedule**:
>
> **type**: string
>
> **type**: object
>
> **status**:
>
> **type**: object
>
> **version**: v1alpha1
>
> **versions**:
>
> \- **name**: v1alpha1
>
> **served**: true
>
> **storage**: true
>
> **status**:
>
> **acceptedNames**:
>
> **kind**: At
>
> **listKind**: AtList
>
> **plural**: ats
>
> **singular**: at
>
> **conditions**:
>
> \- **lastTransitionTime**: \"2019-03-17T09:44:21Z\"
>
> **message**: no conflicts found
>
> **reason**: NoConflicts
>
> **status**: \"True\"
>
> **type**: NamesAccepted
>
> \- **lastTransitionTime**: null
>
> **message**: the initial names have been accepted
>
> **reason**: InitialNamesAccepted
>
> **status**: \"True\"
>
> **type**: Established
>
> **storedVersions**:
>
> \- v1alpha1

您可以看到规范中缺少的名称字段是默认名称，并在状态中反映为已接受名称。 此外，设置以下条件：
===========================================================================================

•NamesAccepted描述规范中的给定名称是否一致且没有冲突。
======================================================

•建立的描述API服务器以status.acceptedNames中的名称提供给定资源。
================================================================

请注意，某些字段可以在创建CRD之后很长时间进行更改。例如，您可以添加短名称或列。 在这种情况下，尽管规范名称存在冲突，但可以建立CRD（即使用旧名称）。 因此，NamesAccepted条件将为false，并且规范名称和接受的名称将有所不同。
==========================================================================================================================================================================================================================

自定义资源的高级功能
====================

在本节中，我们讨论自定义资源的高级功能，例如验证或子资源。
==========================================================

验证自定义资源
--------------

CR可以在创建和更新期间由API服务器验证。这是根据CRD规范的\`\`验证\'\'字段中指定的OpenAPI
v3模式完成的。

当请求创建或更改CR时，将根据该规范验证规范中的JSON对象，如果发生错误，则冲突字段将以HTTP代码400响应返回给用户。图4-2显示了在apiextensions-apiserver内的请求处理程序中进行验证的位置。

可以通过验证准入网络钩子（即使用图灵完整的编程语言）来实现更复杂的验证。图4-2显示了在本节中介绍的基于OpenAPI的验证之后直接调用了这些webhook。在"准入Webhooks"中，我们将了解如何实施和部署准入Webhooks。在那里，我们将研究考虑其他资源的验证，因此远远超出了OpenAPI
v3验证的范围。幸运的是，对于许多用例而言，OpenAPI v3架构就足够了。

![alidation step in the handler stack of the
\`apiextensions-apiserver\`](media/image2.png){width="5.763888888888889in"
height="2.88707239720035in"}

###### *图4-2. apiextensions-apiserver的处理程序堆栈中的验证步骤*

OpenAPI模式语言基于JSON模式标准，该标准使用JSON / YAML本身来表达模式。
这是一个例子：

> **type**: object
>
> **properties**:
>
> **apiVersion**:
>
> **type**: string
>
> **kind**:
>
> **type**: string
>
> **metadata**:
>
> **type**: object
>
> **spec**:
>
> **type**: object
>
> **properties**:
>
> **schedule**:
>
> **type**: string
>
> **pattern**:
> \"\^\\d{4}-(\[0\]\\d\|1\[0-2\])-(\[0-2\]\\d\|3\[01\])\...\"
>
> **command**:
>
> **type**: string
>
> **required**:
>
> \- schedule
>
> \- command
>
> **status**:
>
> **type**: object
>
> **properties**:
>
> **phase**:
>
> **type**: string
>
> **required**:
>
> \- metadata
>
> \- apiVersion
>
> \- kind
>
> \- spec

此架构指定该值实际上是JSON对象;
1即它是一个字符串映射，而不是切片或诸如数字之类的值。
此外，除了元数据，实物和apiVersion（为自定义资源隐式定义）外，它还有两个附加属性：spec和status。

每个对象也是一个JSON对象。
spec具有必填字段的时间表和命令，两者都是字符串。
日程安排必须与ISO日期的格式匹配（此处带有一些正则表达式）。
可选状态属性具有一个名为phase的字符串字段。

##### OPENAPI V3 架构，功能及其未来

在CRD中，OpenAPI v3模式曾经是可选的。在Kubernetes
1.14之前，它们仅用于服务器端验证。为此，它们也可能是不完整的，换句话说，它们可能未指定所有字段。

从Kubernetes 1.15开始，CRD架构将作为Kubernetes
API服务器OpenAPI规范的一部分发布。
Kubectl特别将此用于客户端验证。客户端验证抱怨未知字段。例如，当用户在对象中键入foo：bar并且OpenAPI模式未指定foo时，kubectl将拒绝该对象。因此，优良作法是传递完整的OpenAPI模式。

最后，将来的自定义资源实例将被修剪。这意味着-与本地Kubernetes资源类似-pod一样，未知（未指定）字段将不会保留。这不仅对数据一致性很重要，而且对安全性也很重要。这是CRD的OpenAPI架构应该完整的另一个原因。

有关完整的参考，请参阅OpenAPI v3模式文档。

手动创建OpenAPI模式可能很繁琐。幸运的是，正在通过代码生成使这项工作变得更加容易的工作：Kubebuilder项目（请参阅\`\`Kubebuilder\'\'）已经在sig.k8s.io/controller-tools中开发了crd-gen，并且正在逐步扩展它以便
在其他情况下可用。 Generator crd-schema-gen是这个方向上的crd-gen的分支。

简称和类别
----------

像本地资源一样，自定义资源可能具有较长的资源名称。
它们在API级别上很棒，但是在CLI中键入却很麻烦。
CR也可以具有短名称，例如可以使用Kubectl get ds查询的本地资源守护程序集。
这些短名称也称为别名，每个资源可以有任意多个。

要查看所有可用的短名称，请使用kubectl api-resources命令，如下所示：

> \$ kubectl api-resources
>
> NAME SHORTNAMES APIGROUP NAMESPACED KIND
>
> bindings true Binding
>
> componentstatuses cs false ComponentStatus
>
> configmaps cm true ConfigMap
>
> endpoints ep true Endpoints
>
> events ev true Event
>
> limitranges limits true LimitRange
>
> namespaces ns false Namespace
>
> nodes no false Node
>
> persistentvolumeclaims pvc true PersistentVolumeClaim
>
> persistentvolumes pv false PersistentVolume
>
> pods po true Pod
>
> statefulsets sts apps true StatefulSet
>
> \...

再次，kubectl通过发现信息来了解短名称（请参阅\`\`发现信息\'\'）。
这是一个例子：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: ats.cnat.programming-kubernetes.info
>
> **spec**:
>
> \...
>
> shortNames:
>
> \- at

之后，一个Kubectl at将列出命名空间中的所有CNat CR。

此外，与任何其他资源一样，CR可以是类别的一部分。
最常见的用法是all类，就像在Kubectl中获取全部一样。
它列出了集群中所有面向用户的资源，例如Pod和服务。

集群中定义的CR可以加入类别或通过\`\`类别\'\'字段创建自己的类别：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: ats.cnat.programming-kubernetes.info
>
> **spec**:
>
> \...
>
> categories:
>
> \- all

这样，kubectl get all还将在命名空间中列出cnat CR。

Printer Columns
---------------

Kubectl CLI工具使用服务器端打印来渲染Kubectl get的输出。
这意味着它将查询API Server以显示要显示的列以及每一行中的值。

自定义资源还通过additionalPrinterColumns支持服务器端打印机列。
它们被称为"additional"，因为第一列始终是对象的名称。这些列的定义如下：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **metadata**:
>
> **name**: ats.cnat.programming-kubernetes.info
>
> **spec**:
>
> **additionalPrinterColumns**: (optional)
>
> \- **name**: *kubectl column name*
>
> **type**: *OpenAPI type for the column*
>
> **format**: *OpenAPI format for the column* (optional)
>
> **description**: *human-readable description of the column* (optional)
>
> **priority**: *integer, always zero supported by kubectl*
>
> **JSONPath**: *JSON path inside the CR for the displayed value*

名称字段是列名，类型是规范的数据类型部分中定义的OpenAPI类型，格式（在同一文档中定义）是可选的，并且可能由Kubectl或其他客户端解释。

此外，description是一个可选的人类可读字符串，用于文档目的。
优先级控制以何种方式显示该列的Kubectl模式。 在撰写本文时（使用Kubernetes
1.14），仅支持零，并且所有具有更高优先级的列都被隐藏。

最后，JSONPath定义要显示的值。 这是CR内的简单JSON路径。
在这里，\`\`简单\'\'表示它支持诸如.spec.foo.bar之类的对象字段语法，但不支持遍历数组或类似对象的更复杂的JSON路径。

这样，可以使用additionalPrinterColumns扩展引言中的示例CRD，如下所示

> **additionalPrinterColumns**: *\#(optional)*
>
> \- **name**: schedule
>
> **type**: string
>
> **JSONPath**: .spec.schedule
>
> \- **name**: command
>
> **type**: string
>
> **JSONPath**: .spec.command
>
> \- **name**: phase
>
> **type**: string
>
> **JSONPath**: .status.phase

然后Kubectl将按如下方式渲染一个CNat资源：

> \$ kubectl get ats
>
> NAME SCHEDULER COMMAND PHASE
>
> foo 2019-07-03T02:00:00Z echo \"hello world\" Pending

接下来，我们看一下子资源。

子资源
------

我们在"状态子资源：UpdateStatus"中简要提到了子资源。
子资源是特殊的HTTP终结点，在常规资源的HTTP路径上附加了后缀。
例如，Pod标准HTTP路径为/ api / v1 / namespace / namespace / pods /
name。 Pod具有许多子资源，例如/ logs，/ portforward，/ exec和/ status。
相应的子资源HTTP路径为：

• /api/v1/namespace/namespace/pods/name/logs

• /api/v1/namespace/namespace/pods/name/portforward

• /api/v1/namespace/namespace/pods/name/exec

• /api/v1/namespace/namespace/pods/name/status

子资源端点使用与主资源端点不同的协议。

在撰写本文时，自定义资源支持两个子资源：/规模和/状态。
两者都是选择加入的-也就是说，必须在CRD中明确启用它们。

### 状态资源

/ status子资源用于将用户提供的CR实例的规范与控制器提供的状态分开。
这样做的主要动机是特权分离：

•用户通常不应编写状态字段。

•控制器不应写入规格字段。

RBAC访问控制机制不允许在该级别的规则。 这些规则始终基于资源。 /
status子资源通过提供两个自己的资源端点来解决此问题。
每个都可以由RBAC规则独立控制。 这通常称为规格状态拆分。
这是ats资源的这种规则的示例，该规则仅适用于/ status子资源（而"
ats"将与主资源匹配）：

> **apiVersion**: rbac.authorization.k8s.io/v1
>
> **kind**: Role
>
> **metadata**: \...
>
> **rules**:
>
> \- **apiGroups**: \[\"\"\]
>
> **resources**: \[\"ats/status\"\]
>
> **verbs**: \[\"update\", \"patch\"\]

具有/
status子资源的资源（包括自定义资源）已经更改了语义，对于主要资源端点也是如此：

•他们忽略在创建过程中主HTTP终结点上状态的更改（在创建过程中状态被删除）和更新。

•同样，/
status子资源端点忽略有效负载状态之外的更改。无法在状态终端上创建操作。

•每当元数据之外和状态更改之外的某些内容时（这尤其意味着规格更改），主资源端点将增加元数据生成值。这可以用作控制器的触发器，该控制器指示用户期望已改变。

请注意，通常在更新请求中发送规格和状态，但是从技术上讲，您可以在请求有效负载中忽略其他部分。

还请注意，/
status端点将忽略状态之外的所有内容，包括元数据更改（例如标签或注释）。

启用自定义资源的规范/ status拆分，如下所示：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **spec**:
>
> **subresources**:
>
> **status**: {}
>
> \...

请注意，在该YAML片段的状态字段中分配了空对象。
这是设置没有其他属性的字段的方法。 只是写作

> **subresources**:
>
> **status**:

将导致验证错误，因为在YAML中，结果是状态的空值。

###### 警告

启用规格状态拆分是API的重大更改。 旧控制器将写入主端点。
他们不会注意到从激活拆分开始总是忽略该状态。
同样，新的控制器只有在激活拆分后才能写入新的/状态端点。

在Kubernetes 1.13和更高版本中，可以按版本配置子资源。这使我们能够引入/
status子资源而无需进行重大更改：

> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **spec**:
>
> \...
>
> versions:
>
> \- **name**: v1alpha1
>
> **served**: true
>
> **storage**: true
>
> \- **name**: v1beta1
>
> **served**: true
>
> **subresources**:
>
> **status**: {}

这将为v1beta1启用/ status子资源，但不为v1alpha1启用。

###### NOTE

乐观并发语义（请参见\`\`乐观并发\'\'）与主要资源端点相同;
也就是说，状态和规格共享相同的资源版本计数器，并且/状态更新可能会由于写入主资源而发生冲突，反之亦然。
换句话说，存储层上没有规格和状态的分离。

### SCALE SUBRESOURCE

可用于自定义资源的第二个子资源是/ scale。 /
scale子资源是资源的（投影）2视图，使我们只能查看和修改副本值。
该子资源以Kubernetes中的部署和副本集之类的资源而闻名，显然可以放大和缩小。

Kubectl scale命令使用了/ scale子资源;
例如，以下将修改给定实例中的指定副本值：

> \$ kubectl scale \--replicas=3 *your-custom-resource* -v=7
>
> I0429 21:17:53.138353 66743 round_trippers.go:383\] PUT
>
> https://*host*/apis/*group*/v1/*your-custom-resource*/scale
>
> **apiVersion**: apiextensions.k8s.io/v1beta1
>
> **kind**: CustomResourceDefinition
>
> **spec**:
>
> **subresources**:
>
> **scale**:
>
> **specReplicasPath**: .spec.replicas
>
> **statusReplicasPath**: .status.replicas
>
> **labelSelectorPath**: .status.labelSelector
>
> \...

这样，副本值的更新将被写入spec.replicas并在GET期间从那里返回。

标签选择器不能通过/ status子资源进行更改，只能读取。
其目的是为控制器提供信息以计数相应的对象。
例如，ReplicaSet控制器计算满足此选择器的相应容器的数量。

标签选择器是可选的。
如果您的自定义资源语义不适合标签选择器，则不要为其中的一个指定JSON路径。

以前的Kubectl标度示例\--replicas = 3 \...将值3写入spec.replicas。
当然，可以使用任何其他简单的JSON路径；
例如，根据上下文，specinstances或spec.size将是一个明智的字段名称。

##### 整数值与创建并删除副本的控制器之间的关系

我们仅谈论在自定义资源中读取和设置副本整数值。
其背后的实际语义（例如，创建和删除实际副本的实例）必须由自定义控制器实现（请参见"控制器和运算符"）。

从端点读取或写入端点的对象的类型是来自autoscaling / v1 API组的scale。
看起来是这样的：

> **type** Scale **struct** {
>
> metav1.TypeMeta \`json:\",inline\"\`
>
> *// Standard object metadata; More info: https://git.k8s.io/*
>
> *// community/contributors/devel/api-conventions.md\#metadata.*
>
> *// +optional*
>
> metav1.ObjectMeta \`json:\"metadata,omitempty\"\`
>
> *// defines the behavior of the scale. More info:
> https://git.k8s.io/community/*
>
> *// contributors/devel/api-conventions.md\#spec-and-status.*
>
> *// +optional*
>
> Spec ScaleSpec \`json:\"spec,omitempty\"\`
>
> *// current status of the scale. More info:
> https://git.k8s.io/community/*
>
> *// contributors/devel/api-conventions.md\#spec-and-status.
> Read-only.*
>
> *// +optional*
>
> Status ScaleStatus \`json:\"status,omitempty\"\`
>
> }
>
> *// ScaleSpec describes the attributes of a scale subresource.*
>
> **type** ScaleSpec **struct** {
>
> *// desired number of instances for the scaled object.*
>
> *// +optional*
>
> Replicas **int32** \`json:\"replicas,omitempty\"\`
>
> }
>
> *// ScaleStatus represents the current status of a scale subresource.*
>
> **type** ScaleStatus **struct** {
>
> *// actual number of observed instances of the scaled object.*
>
> Replicas **int32** \`json:\"replicas\"\`
>
> *// label query over pods that should match the replicas count. This
> is the*
>
> *// same as the label selector but in the string format to avoid*
>
> *// introspection by clients. The string will be in the same*
>
> *// format as the query-param syntax. More info about label
> selectors:*
>
> *// http://kubernetes.io/docs/user-guide/labels\#label-selectors.*
>
> *// +optional*
>
> Selector **string** \`json:\"selector,omitempty\"\`
>
> }
>
> 实例将如下所示：
>
> **metadata**:
>
> **name**: *cr-name*
>
> **namespace**: *cr-namespace*
>
> **uid**: *cr-uid*
>
> **resourceVersion**: *cr-resource-version*
>
> **creationTimestamp**: *cr-creation-timestamp*
>
> **spec**:
>
> **replicas**: 3
>
> **status**:
>
> **replicas**: 2
>
> **selector**: \"environment = production\"

请注意，主要资源和/ scale子资源的乐观并发语义相同。
也就是说，主要资源写入可能与/ scale写入冲突，反之亦然。

开发者对自定义资源的看法
========================

可以使用许多客户端从Golang访问自定义资源。 我们将专注于：

使用"client-go dynamic client"（请参阅"dynamic client"）

使用typed client：

♣由kubernetes-sigs / controller-runtime提供并由Operator
SDK和Kubebuilder使用（请参阅"controller-runtime Client of Operator SDK
and Kubebuilder"）

♣由client-gen生成，就像k8s.io/client-go/kubernetes中一样（请参阅\`\`通过Typed
client created via client-gen\'\'）

使用哪个客户端的选择主要取决于要编写的代码的上下文，尤其取决于实现的逻辑的复杂性和要求（例如，要动态并支持编译时未知的GVK）。

前面的客户列表：

•处理未知GVK的灵活性降低。

•增加类型安全性。

•提高了它们提供的Kubernetes API功能的完整性。

Dynamic Client
--------------

k8s.io/client-go/dynamic中的动态客户端完全不了解已知的GVK。
它甚至不使用非结构化。非结构化以外的任何Go类型，它仅包装json.Unmarshal及其输出。

动态客户端既不使用方案也不使用RESTMapper。
这意味着开发人员必须通过以GVR形式提供资源（请参阅\`\`
Resources\'\'）来手动提供有关类型的所有知识：

> schema.GroupVersionResource{
>
> Group: \"apps\",
>
> Version: \"v1\",
>
> Resource: \"deployments\",
>
> }

如果REST客户端配置可用（请参阅\`\` Creating and Using a
Client\'\'），则可以在一行中创建动态客户端：

> client, err := NewForConfig(cfg)

对给定GVR的REST访问非常简单：

> client.Resource(gvr).
>
> Namespace(namespace).Get(\"foo\", metav1.GetOptions{})

这将为您提供给定名称空间中的部署foo。

###### NOTE

您必须知道资源的范围（即，它是命名空间还是集群作用域）。
集群范围内的资源只需省略Namespace（namespace）调用即可。

动态客户端的输入和输出是\*
unstructured.Unstructured的-即，一个对象包含与json.Unmarshal相同的数据结构。

•对象由map \[string\] interface {}表示。

•数组由\[\] interface {}表示。

•基本类型为string，bool，float64或int64。

方法UnstructuredContent（）提供对非结构化对象内部此数据结构的访问（我们也可以访问Unstructured.Object）。
同一包中有一些帮助程序，以使字段的检索变得容易并且可以对对象进行操作，例如：

> name, found, err := unstructured.NestedString(u.Object, \"metadata\",
> \"name\")

它返回部署的名称-在这种情况下为" foo"。
如果实际找到了该字段（不是为空，而是实际存在），则found为true。
错误报告现有字段的类型是否意外（即在这种情况下不是字符串）。
其他帮助程序是通用的，一次带有结果的深层副本，一次没有：

> **func** NestedFieldCopy(obj **map**\[**string**\]**interface**{},
> fields \...**string**)
>
> (**interface**{}, **bool**, **error**)
>
> **func** NestedFieldNoCopy(obj **map**\[**string**\]**interface**{},
> fields \...**string**)
>
> (**interface**{}, **bool**, **error**)

还有其他类型化变体进行类型转换，如果失败，则返回错误：

> **func** NestedBool(obj **map**\[**string**\]**interface**{}, fields
> \...**string**) (**bool**, **bool**, **error**)
>
> **func** NestedFloat64(obj **map**\[**string**\]**interface**{},
> fields \...**string**)
>
> (**float64**, **bool**, **error**)
>
> **func** NestedInt64(obj **map**\[**string**\]**interface**{}, fields
> \...**string**) (**int64**, **bool**, **error**)
>
> **func** NestedStringSlice(obj **map**\[**string**\]**interface**{},
> fields \...**string**)
>
> (\[\]**string**, **bool**, **error**)
>
> **func** NestedSlice(obj **map**\[**string**\]**interface**{}, fields
> \...**string**)
>
> (\[\]**interface**{}, **bool**, **error**)
>
> **func** NestedStringMap(obj **map**\[**string**\]**interface**{},
> fields \...**string**)
>
> (**map**\[**string**\]**string**, **bool**, **error**)

最后是一个通用的setter：

> **func** SetNestedField(obj, value, path\...)

在Kubernetes本身中，动态客户端用于通用控制器，例如垃圾收集控制器，该控制器删除其父级已消失的对象。垃圾收集控制器可与系统中的任何资源一起使用，因此可以广泛使用动态客户端。

Typed Clients
-------------

类型化的客户端不使用类似于map \[string\] interface
{}的通用数据结构，而是使用实际的Golang类型，这些类型对于每个GVK都是不同的和特定的。
它们更易于使用，类型安全性大大提高，并使代码更简洁易读。
不利的一面是，它们的灵活性较差，因为必须在编译时知道已处理的类型，并生成那些客户端，这会增加复杂性。

在讨论两种类型的客户端的实现之前，让我们研究一下Golang类型系统中类型的表示（有关Kubernetes类型系统背后的理论，请参见\`\`
API Machinery in Depth\'\'）。

###  TYPE分析

Kinds以Golang的structs表示。通常将structs命名为种类（尽管从技术上讲不是必须的），并将其放在与GVK的Group和version相对应的包装中。
一个常见的约定是将GVK的Group/version放入Go包中：

pkg / apis / group / version

并在types.go文件中定义Golang 的stucts kinds。

对应于GVK的每种Golang类型都从包k8s.io/apimachinery/pkg/apis/meta/v1中嵌入TypeMeta结构。
TypeMeta仅由Kind和ApiVersion字段组成：

> **type** TypeMeta **struct** {
>
> *// +optional*
>
> APIVersion **string** \`json:\"apiVersion,omitempty\"
> yaml:\"apiVersion,omitempty\"\`
>
> *// +optional*
>
> Kind **string** \`json:\"kind,omitempty\" yaml:\"kind,omitempty\"\`
>
> }

此外，每种顶级类型（即具有自己的端点并因此具有一个（或多个）对应的GVR（请参见\`\`
REST
Mapping\'\'））必须存储名称，命名空间资源的命名空间以及一个漂亮的名称。
大量其他元级字段。所有这些都存储在软件包k8s.io/apimachinery/pkg/apis/meta/v1中名为ObjectMeta的结构中：

> **type** ObjectMeta **struct** {
>
> Name **string** \`json:\"name,omitempty\"\`
>
> Namespace **string** \`json:\"namespace,omitempty\"\`
>
> UID types.UID \`json:\"uid,omitempty\"\`
>
> ResourceVersion **string** \`json:\"resourceVersion,omitempty\"\`
>
> CreationTimestamp Time \`json:\"creationTimestamp,omitempty\"\`
>
> DeletionTimestamp \*Time \`json:\"deletionTimestamp,omitempty\"\`
>
> Labels **map**\[**string**\]**string** \`json:\"labels,omitempty\"\`
>
> Annotations **map**\[**string**\]**string**
> \`json:\"annotations,omitempty\"\`
>
> \...
>
> }

还有许多其他字段。
我们强烈建议您阅读广泛的内联文档，因为它可以很好地展示Kubernetes对象的核心功能。

Kubernetes顶级类型（即具有嵌入式TypeMeta和嵌入式ObjectMeta的类型，并且在这种情况下持久化到etcd中）在某种意义上彼此非常相似，因为它们通常具有规范和状态。
请从k8s.io/kubernetes/apps/v1/types.go查看以下部署示例：

> **type** Deployment **struct** {
>
> metav1.TypeMeta \`json:\",inline\"\`
>
> metav1.ObjectMeta \`json:\"metadata,omitempty\"\`
>
> Spec DeploymentSpec \`json:\"spec,omitempty\"\`
>
> Status DeploymentStatus \`json:\"status,omitempty\"\`
>
> }

尽管规格和状态类型的实际内容在不同类型之间存在显着差异，但这在Kubernetes中被划分为规格和状态是一个常见主题甚至是约定，尽管在技术上不是必需的。
因此，优良作法是也遵循CRD的这种结构。 一些CRD功能甚至需要这种结构。
例如，自定义资源的/ status子资源（请参见"
Status子资源"）（启用后）始终仅适用于自定义资源实例的status子结构。无法重命名。

### GOLANG 包结构

如我们所见，Golang类型通常放在pkg / apis / group /
version包中的一个名为types.go的文件中。
除了该文件之外，我们现在还需要处理几个文件。
其中一些是由开发人员手动编写的，而另一些是由代码生成器生成的。有关详细信息，请参见第5章。

doc.go文件描述了API的用途，并包含许多程序包全局代码生成标签：

> *// Package v1alpha1 contains the cnat v1alpha1 API group*
>
> *//*
>
> *// +k8s:deepcopy-gen=package*
>
> *// +groupName=cnat.programming-kubernetes.info*
>
> **package** v1alpha1

接下来，register.go包括一些帮助程序，以将自定义资源Golang类型注册到一个方案中（请参阅\`\`
Scheme\'\'）：

> **package** *version*
>
> **import** (
>
> metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"
>
> \"k8s.io/apimachinery/pkg/runtime\"
>
> \"k8s.io/apimachinery/pkg/runtime/schema\"
>
> group \"*repo*/pkg/apis/*group*\"
>
> )
>
> *// SchemeGroupVersion is group version used to register these
> objects*
>
> **var** SchemeGroupVersion = schema.GroupVersion{
>
> Group: group.GroupName,
>
> Version: \"*version*\",
>
> }
>
> *// Kind takes an unqualified kind and returns back a Group qualified
> GroupKind*
>
> **func** Kind(kind **string**) schema.GroupKind {
>
> **return** SchemeGroupVersion.WithKind(kind).GroupKind()
>
> }
>
> *// Resource takes an unqualified resource and returns a Group*
>
> *// qualified GroupResource*
>
> **func** Resource(resource **string**) schema.GroupResource {
>
> **return** SchemeGroupVersion.WithResource(resource).GroupResource()
>
> }
>
> **var** (
>
> SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
>
> AddToScheme = SchemeBuilder.AddToScheme
>
> )
>
> *// Adds the list of known types to Scheme.*
>
> **func** addKnownTypes(scheme \*runtime.Scheme) **error** {
>
> scheme.AddKnownTypes(SchemeGroupVersion,
>
> &SomeKind{},
>
> &SomeKindList{},
>
> )
>
> metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
>
> **return** **nil**
>
> }

然后，zz_generation.deepcopy.go在自定义资源Golang顶级类型（即上述示例代码中的SomeKind和SomeKindList）上定义了Deep-copy方法。
此外，所有子结构（例如spec和state的子结构）也可以深层复制。

由于该示例在doc.go中使用了标记+ k8s：deepcopy-gen =
package，因此深度复制生成是基于退出的; 也就是说，对于不使用+
k8s退出的包中的每种类型，都会生成DeepCopy方法：deepcopy-gen = false。
有关更多详细信息，请参见第5章，尤其是" deepcopy-gen Tags"。

### 通过CLIENT 生成的 VIA CLIENT-GEN

有了API软件包pkg / apis / group /
version，客户端生成器client-gen默认情况下以pkg / generated / clientset /
versioned创建一个类型化的客户端（有关详细信息，请参见第5章，尤其是\`\`client-gen
Tag\'\'）。 （在旧版本的生成器中为pkg / client / clientset /
versioned）。 更确切地说，生成的顶级对象是客户端集。 它包含许多API
Groups，version和resources。

top-level文件如下所示：

> *// Code generated by client-gen. DO NOT EDIT.*
>
> **package** versioned
>
> **import** (
>
> discovery \"k8s.io/client-go/discovery\"
>
> rest \"k8s.io/client-go/rest\"
>
> flowcontrol \"k8s.io/client-go/util/flowcontrol\"
>
> cnatv1alpha1
> \"\.../cnat/cnat-client-**go**/pkg/generated/clientset/versioned/
>
> )
>
> **type** Interface **interface** {
>
> Discovery() discovery.DiscoveryInterface
>
> CnatV1alpha1() cnatv1alpha1.CnatV1alpha1Interface
>
> }
>
> *// Clientset contains the clients for groups. Each group has exactly
> one*
>
> *// version included in a Clientset.*
>
> **type** Clientset **struct** {
>
> \*discovery.DiscoveryClient
>
> cnatV1alpha1 \*cnatv1alpha1.CnatV1alpha1Client
>
> }
>
> *// CnatV1alpha1 retrieves the CnatV1alpha1Client*
>
> **func** (c \*Clientset) CnatV1alpha1()
> cnatv1alpha1.CnatV1alpha1Interface {
>
> **return** c.cnatV1alpha1
>
> }
>
> *// Discovery retrieves the DiscoveryClient*
>
> **func** (c \*Clientset) Discovery() discovery.DiscoveryInterface {
>
> \...
>
> }
>
> *// NewForConfig creates a new Clientset for the given config.*
>
> **func** NewForConfig(c \*rest.Config) (\*Clientset, **error**) {
>
> \...
>
> }

Client
Set由接口Interface表示，并提供对每个版本的API组客户端接口的访问权限，例如此示例代码中的CnatV1alpha1Interface：

> **type** CnatV1alpha1Interface **interface** {
>
> RESTClient() rest.Interface
>
> AtsGetter
>
> }
>
> *// AtsGetter has a method to return a AtInterface.*
>
> *// A group\'s client should implement this interface.*
>
> **type** AtsGetter **interface** {
>
> Ats(namespace **string**) AtInterface
>
> }
>
> *// AtInterface has methods to work with At resources.*
>
> **type** AtInterface **interface** {
>
> Create(\*v1alpha1.At) (\*v1alpha1.At, **error**)
>
> Update(\*v1alpha1.At) (\*v1alpha1.At, **error**)
>
> UpdateStatus(\*v1alpha1.At) (\*v1alpha1.At, **error**)
>
> Delete(name **string**, options \*v1.DeleteOptions) **error**
>
> DeleteCollection(options \*v1.DeleteOptions, listOptions
> v1.ListOptions) **error**
>
> Get(name **string**, options v1.GetOptions) (\*v1alpha1.At, **error**)
>
> List(opts v1.ListOptions) (\*v1alpha1.AtList, **error**)
>
> Watch(opts v1.ListOptions) (watch.Interface, **error**)
>
> Patch(name **string**, pt types.PatchType, data \[\]**byte**,
> subresources \...**string**)
>
> (result \*v1alpha1.At, err **error**)
>
> AtExpansion
>
> }

可以使用NewForConfig帮助函数来创建客户端集的实例。 这类似于在Creating
and Using a Client":中讨论的核心Kubernetes资源的客户端：

> **import** (
>
> metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"
>
> \"k8s.io/client-go/tools/clientcmd\"
>
> client
> \"github.com/\.../cnat/cnat-client-go/pkg/generated/clientset/versioned\"
>
> )
>
> kubeconfig = flag.String(\"kubeconfig\", \"\~/.kube/config\",
> \"kubeconfig file\")
>
> flag.Parse()
>
> config, err := clientcmd.BuildConfigFromFlags(\"\", \*kubeconfig)
>
> clientset, err := client.NewForConfig(config)
>
> ats := clientset.CnatV1alpha1Interface().Ats(\"default\")
>
> book, err := ats.Get(\"kubernetes-programming\", metav1.GetOptions{})

如您所见，代码生成机制使我们能够以与核心Kubernetes资源相同的方式为自定义资源编程逻辑。还可以使用诸如informers之类的高级工具。
请参阅第5章中的informer-gen。

controller-runtime Client of Operator SDK and Kubebuilder
---------------------------------------------------------

为了完整起见，我们想快速浏览一下第三个客户端，该客户端在\`\`开发人员对自定义资源的视图\'\'中列为第二个选项。
\`\`控制器运行时\'\'项目为第6章中介绍的操作员解决方案Operator
SDK和Kubebuilder提供了基础，其中包括使用\`\`类型剖析\'\'中介绍的Go类型的客户端。

与之前的"通过client-gen创建的类型化客户端"的client-gen生成的客户端相反，并且类似于"
Dynamic Client"，此客户端是一个实例，能够处理在给定方案中注册的任何种类
。

它使用来自API服务器的发现信息将种类映射到HTTP路径。
请注意，第6章将更详细地介绍如何将此客户端用作这两个运营商解决方案的一部分。

> 这是一个如何使用控制器运行时的简单示例：
>
> **import** (
>
> \"flag\"
>
> corev1 \"k8s.io/api/core/v1\"
>
> metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"
>
> \"k8s.io/client-go/kubernetes/scheme\"
>
> \"k8s.io/client-go/tools/clientcmd\"
>
> runtimeclient \"sigs.k8s.io/controller-runtime/pkg/client\"
>
> )
>
> kubeconfig = flag.String(\"kubeconfig\", \"\~/.kube/config\",
> \"kubeconfig file path\")
>
> flag.Parse()
>
> config, err := clientcmd.BuildConfigFromFlags(\"\", \*kubeconfig)
>
> cl, \_ := runtimeclient.New(config, client.Options{
>
> Scheme: scheme.Scheme,
>
> })
>
> podList := &corev1.PodList{}
>
> err := cl.List(context.TODO(), client.InNamespace(\"default\"),
> podList)

客户端对象的List（）方法接受给定scheme中注册的任何
runtime对象。在这种情况下，该对象是从client-go借来的对象，其中注册了所有标准Kubernetes类型。
在内部客户端使用给定的方案将Golang类型\* corev1.PodList映射到GVK。
第二步，List（）方法使用发现信息来获取Pod的GVR，即schema.GroupVersionResource
{""，" v1"，" pods"}}，因此访问/ api / v1 / namespace / default /
pods以获取传递的名称空间中的pod列表。

相同的逻辑可以与自定义资源一起使用。
主要区别是使用包含传递的Go类型的自定义方案：

> **import** (
>
> \"flag\"
>
> corev1 \"k8s.io/api/core/v1\"
>
> metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"
>
> \"k8s.io/client-go/kubernetes/scheme\"
>
> \"k8s.io/client-go/tools/clientcmd\"
>
> runtimeclient \"sigs.k8s.io/controller-runtime/pkg/client\"
>
> cnatv1alpha1
> \"github.com/\.../cnat/cnat-kubebuilder/pkg/apis/cnat/v1alpha1\"
>
> )
>
> kubeconfig = flag.String(\"kubeconfig\", \"\~/.kube/config\",
> \"kubeconfig file\")
>
> flag.Parse()
>
> config, err := clientcmd.BuildConfigFromFlags(\"\", \*kubeconfig)
>
> crScheme := runtime.NewScheme()
>
> cnatv1alpha1.AddToScheme(crScheme)
>
> cl, \_ := runtimeclient.New(config, client.Options{
>
> Scheme: crScheme,
>
> })
>
> list := &cnatv1alpha1.AtList{}
>
> err := cl.List(context.TODO(), client.InNamespace(\"default\"), list)

请注意List（）命令的调用完全不变。

假设您编写了一个使用此客户端访问许多不同类型的运算符。使用"Typed client
created via
client-gen"的类型化客户端，您将不得不将许多不同的客户端传递给运算符，从而使管道代码相当复杂。相比之下，假设所有控制器/运行时客户端都处于一种方案中，则此处给出的controller-runtime客户端只是一个对象。

这三种类型的客户都有其用途，根据使用环境的不同，其优缺点也不同。在处理未知对象的通用控制器中，只能使用动态客户端。在类型安全有助于很大程度上确保代码正确性的控制器中，生成的客户端非常合适。
Kubernetes项目本身有很多贡献者，以至于即使有很多人对其进行扩展和重写，代码的稳定性也非常重要。如果重要的是方便和高速且管道数量最少，那么generated
clients客户端非常合适。

摘要
====

在本章中，我们向您介绍了自定义资源，即Kubernetes生态系统中使用的中央扩展机制。
到目前为止，您应该对它们的功能和局限性以及可用的客户有充分的了解。

现在，让我们继续进行代码生成以管理上述资源。

1，不要在这里混淆Kubernetes和JSON对象。
后者只是字符串映射的另一个术语，用于JSON上下文和OpenAPI。

2这里的\`\`
Projective\'\'是指规模对象是主要资源的投影，从某种意义上说，它仅显示某些字段而隐藏其他所有内容。

---
title: 第五章
category: 代码自动生成
order: 2
---

第五章. 代码自动生成
====================

在本章中，您将学习如何在Go项目中使用Kubernetes代码生成器以自然方式编写自定义资源。
代码生成器在Kubernetes原生资源的实现中被大量使用，在这里我们将使用相同的生成器。

为什么要自动生成代码？
======================

Go是一种设计简单的语言。
它缺乏以通用（即与类型无关）的方式在不同数据类型上表达算法的高级甚至元编程类机制。"Go
way"是改用外部代码生成。

在Kubernetes开发过程的早期，随着更多资源被添加到系统中，越来越多的代码不得不被重写。
代码生成使此代码的维护更加容易。
很早就创建了Gengo库，并最终基于Gengo开发了k8s.io/code-generator作为生成器的外部可用集合。
我们将在以下各节中将这些生成器用于CR。

Calling the Generators
======================

通常，在每个控制器项目中，代码生成器的调用方式几乎相同。仅软件包，组名和API版本不同。调用脚本k8s.io/code-generator/generate-groups.sh或bash脚本（如hack
/ update-codegen.sh）是从构建系统向CR
Go类型添加代码生成的最简单方法（请参见本书的GitHub存储库 ）。

请注意，由于非常特殊的要求并且经常出于历史原因，某些项目直接调用生成器二进制文件。
对于为CR建立控制器的用例来说，只需从k8s.io/code-generator存储库中调用generate-groups.sh脚本会容易得多：

> \$ vendor/k8s.io/code-generator/generate-groups.sh all **\\**
>
> github.com/programming-kubernetes/cnat/cnat-client-go/pkg/generated
>
> github.com/programming-kubernetes/cnat/cnat-client-go/pkg/apis **\\**
>
> cnat:v1alpha1 **\\**
>
> \--output-base \"\${GOPATH}/src\" **\\**
>
> \--go-header-file \"hack/boilerplate.go.txt\"

在这里，所有这些均指为CR调用所有四个标准代码生成器：

deepcopy-gen

> Generates func (t \*T) DeepCopy() \*T and func (t
> \*T) DeepCopyInto(\*T) methods.

client-gen

> Creates typed client sets.

informer-gen

> Creates informers for CRs that offer an event-based interface to react
> to changes of CRs on the server.

lister-gen

> Creates listers for CRs that offer a read-only caching layer
> for GET and LIST requests.

最后两个是构建控制器的基础（请参见\`\` Controllers和Operators\'\'）。
这四个代码生成器使用与Kubernetes上游控制器所使用的相同的机制和软件包，为构建功能完备，可用于生产的控制器奠定了强大的基础。

###### 注意

k8s.io/code-generator中还有更多的生成器，主要用于其他环境。例如，如果您构建自己的聚合API
Server（请参见第8章），则除了version、type之外，您还将使用内部类型，并且必须定义默认功能。然后可以通过从k8s.io/code-generator调用generate-internal-groups.sh脚本来访问这两个生成器：

conversion-gen

创建用于在内部和外部类型之间转换的函数。

defaulter-gen

负责默认某些字段。

现在让我们详细查看generate-groups.sh的参数：

•第二个参数是所生成的客户端，列表程序和通知程序的目标程序包名称。

•第三个参数是API组的基本软件包。

•第四个参数是用空格分隔的API组列表及其版本。

•\--output-base作为标志传递给所有生成器，以定义找到给定包的基本目录。

•\--go-header-file使我们能够将版权标题放入生成的代码中。

一些生成器（如deepcopy-gen）直接在API组包中创建文件。这些文件遵循带有zz_Generated的标准命名方案。前缀，这样很容易将它们从版本控制系统中排除（例如，通过.gitignore文件），尽管大多数项目决定检查生成的文件，因为围绕代码生成器的Go工具开发不完善.1

如果项目遵循k8s.io/sample-controller的模式-sample-controller是一个蓝图项目，它将复制Kubernetes本身内置的许多控制器建立的模式-那么代码生成将以以下代码开头：

\$ hack / update-codegen.sh

按照"sample-controller+client-go"中的"Following
sample-controller"变体中的" cnat"示例进行操作。

###### TIP

通常，除了hack / update-codegen.sh脚本外，还有另一个名为hack /
verify-codegen.sh的脚本。

该脚本调用hack /
update-codegen.sh脚本并检查是否有任何更改，如果生成的文件不是最新的，则以非零返回码终止。

这对于持续集成（CI）脚本非常有帮助：如果开发人员无意中修改了文件，或者如果文件刚刚过时，CI会注意到并报错

标签控制器生成
==============

虽然某些代码生成器的行为是通过前面所述的命令行标志（尤其是要处理的软件包）控制的，但更多的属性是通过Go文件中的Tag控制的。
Tag是采用以下格式的特殊格式的Go注释：

// + some-tag

// + some-other-tag = value

标签有两种：

•打包行上方的全局标签在名为doc.go的文件中

•类型声明上方的本地标签（例如，struct定义上方）

根据所讨论的tag，注释的位置可能很重要。

##### 准确的遵循实例 (包括注释框) 

在类型（或全局标签的包装行）正上方的注释中必须包含多个标签，而其他标签必须与类型（或包装行）分开，并且它们之间必须至少有一个空行
。 例如：

> *// +second-comment-block-tag*
>
> *// +first-comment-block-tag*
>
> **type** Foo **struct** {
>
> }

这种区别的原因是历史性的：Kubernetes中的API文档生成器曾经不了解代码生成标签，而是仅导出第一个注释块。
因此，该块中的标签将显示在API HTML文档中。

代码生成器标签解析逻辑并不总是很一致，并且错误处理常常远非完美。
尽管每个版本都对此进行了改进，但请准备好非常精确地遵循现有示例-例如，空行可能很重要。

Global Tags
-----------

全局标签被写入软件包的doc.go中。 典型的pkg / apis / group / version /
doc.go文件如下所示：

> *// +k8s:deepcopy-gen=package*
>
> *// Package v1 is the v1alpha1 version of the API.*
>
> *// +groupName=cnat.programming-kubernetes.info*
>
> **package** v1alpha1

该文件的第一行告诉deepcopy-gen默认为该包中的每种类型创建深度复制方法。如果您的类型不需要，不需要或什至无法进行深度复制，则可以使用本地标签///
+ k8s：deepcopy-gen =
false退出它们。如果未启用包范围的深度复制，则必须通过//
k8s：deepcopy-gen = true选择每种所需类型的深度复制。

第二个标签是/// + groupName =
example.com，用于定义标准API组名称。如果转到父程序包名称与组名称不匹配，则此标记是必需的。

此处显示的文件实际上来自cnat client-go示例pkg / apis / cnat / v1alpha1 /
doc.go文件（请参阅以下示例控制器）。那里，cnat是父包，但是cnat.programming-kubernetes.info是组名。

使用// +
groupName标签，客户端生成器（请参阅\`\`通过client-gen创建的类型化客户端\'\'）将使用正确的HTTP路径/apis/foo.project.example.com生成客户端。除了+
groupName之外，还有+
groupGoName，它定义了要使用的自定义Go标识符（用于变量和类型名称），而不是父程序包名称。例如，在默认情况下，生成器将使用大写的父包名称进行标识，在我们的示例中为Cnat。更好的标识符是"
Cloud Native At"的CNAt。使用// + groupGoName =
CNAt，我们可以使用它而不是Cnat（尽管在此示例中我们不这样做，我们仍然使用Cnat），并且使用client-gen结果如下所示：

> **type** Interface **interface** {
>
> Discovery() discovery.DiscoveryInterface
>
> CNatV1() atv1alpha1.CNatV1alpha1Interface
>
> }

Local Tags
----------

本地标记直接写在API类型上方或上方的第二个注释块中。
以下是cnat示例的types.go文件中的主要类型：

> *// AtSpec defines the desired state of At*
>
> **type** AtSpec **struct** {
>
> *// Schedule is the desired time the command is supposed to be
> executed.*
>
> *// Note: the format used here is UTC time https://www.utctime.net*
>
> Schedule **string** \`json:\"schedule,omitempty\"\`
>
> *// Command is the desired command (executed in a Bash shell) to be
> executed.*
>
> Command **string** \`json:\"command,omitempty\"\`
>
> *// Important: Run \"make\" to regenerate code after modifying this
> file*
>
> }
>
> *// AtStatus defines the observed state of At*
>
> **type** AtStatus **struct** {
>
> *// Phase represents the state of the schedule: until the command is
> executed*
>
> *// it is PENDING, afterwards it is DONE.*
>
> Phase **string** \`json:\"phase,omitempty\"\`
>
> *// Important: Run \"make\" to regenerate code after modifying this
> file*
>
> }
>
> *// +genclient*
>
> *//
> +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object*
>
> *// At runs a command at a given schedule.*
>
> **type** At **struct** {
>
> metav1.TypeMeta \`json:\",inline\"\`
>
> metav1.ObjectMeta \`json:\"metadata,omitempty\"\`
>
> Spec AtSpec \`json:\"spec,omitempty\"\`
>
> Status AtStatus \`json:\"status,omitempty\"\`
>
> }
>
> *//
> +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object*
>
> *// AtList contains a list of At*
>
> **type** AtList **struct** {
>
> metav1.TypeMeta \`json:\",inline\"\`
>
> metav1.ListMeta \`json:\"metadata,omitempty\"\`
>
> Items \[\]At \`json:\"items\"\`
>
> }

在以下各节中，我们将遍历此示例的标记。

###### TIP

在此示例中，API文档位于第一个注释块中，而我们将标签放入了第二个注释块中。
如果您为此目的使用某些工具来提取Go
doc注释，则有助于将标记排除在API文档之外。

deepcopy-gen Tags
-----------------

默认情况下，通常会通过全局// k8s：deepcopy-gen = package标签（请参阅\`\`
Global Tags\'\'）为所有类型启用深度复制方法生成，即可能会退出。
但是，在前面的示例文件（实际上是整个程序包）中，所有API类型都需要深度复制方法。
因此，我们不必在本地选择退出。

如果我们在API类型包中有一个辅助结构（通常不建议这样做以保持API包的清洁），我们将不得不禁用深拷贝生成。
例如：

> *// +k8s:deepcopy-gen=false*
>
> *//*
>
> *// Helper is a helper struct, not an API type.*
>
> **type** Helper **struct** {
>
> \...
>
> }

runtime.Object and DeepCopyObject
---------------------------------

有一个特殊的Deep-copy标签需要更多说明：

> *//
> +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object*

在\`\`Go中的Kubernetes对象\'\'中，我们看到运行时。对象必须实现DeepCopyObject（）runtime.Object方法。
原因是Kubernetes中的通用代码必须能够创建对象的深层副本。
这种方法可以做到这一点。

##### 历史背景

在1.8之前的版本中，该方案（请参阅\`\`
Scheme\'\'）还保留了对特定于类型的深度复制功能的引用，并且具有基于反射的深度复制实现。两种机制都是导致许多不平凡且难以发现的错误的原因。
因此，Kubernetes使用runtime.Object接口中的DeepCopyObject方法切换到静态深度复制。

eepCopyObject（）方法除了调用生成的DeepCopy方法外没有其他作用。
后者的签名因类型而异(DeepCopy() \*T depends on T).。
前者的签名始终是DeepCopyObject（）runtime.Object：

> **func** (in \*T) DeepCopyObject() runtime.Object {
>
> **if** c := in.DeepCopy(); c != **nil** {
>
> **return** c
>
> } **else** {
>
> **return** **nil**
>
> }
>
> }

将本地标记

//k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object放在顶级API类型上方，以使用deepcopy-gen生成此方法。
这告诉deepcopy-gen为runtime.Object创建这样的方法，称为DeepCopyObject（）。

###### TIP

在前面的示例中，At和AtList都是顶级类型，因为它们被用作运行时对象。

根据经验，顶级类型是嵌入了metav1.TypeMeta的类型。

碰巧其他接口需要一种深度复制的方法。
例如，如果API类型具有接口类型为Foo的字段，通常就是这种情况：

> **type** SomeAPIType **struct** {
>
> Foo Foo \`json:\"foo\"\`
>
> }

如我们所见，API类型必须是可深度复制的，因此字段Foo也必须被深度复制。
如何在不向Foo接口中添加DeepCopyFoo（）Foo的情况下（没有类型转换的情况下）执行此操作？

> **type** Foo **interface** {
>
> \...
>
> DeepCopyFoo() Foo
>
> }

在这种情况下，可以使用相同的标签：

> *// +k8s:deepcopy-gen:interfaces=\<package\>.Foo*
>
> **type** FooImplementation **struct** {
>
> \...
>
> }

在Kubernetes源代码中实际使用此标记的地方还有runtime.Object以外的一些示例：

> *//
> +k8s:deepcopy-gen:interfaces=\.../pkg/registry/rbac/reconciliation.RuleOwner*
>
> *//
> +k8s:deepcopy-gen:interfaces=\.../pkg/registry/rbac/reconciliation.RoleBinding*

client-gen Tags
---------------

最后，有许多标记可控制client-gen，我们在前面的示例中在At和AtList中看到了其中一个：

// + genclient

它告诉client-gen为该类型创建一个客户端（始终选择启用）。
请注意，您不必也不必将其置于API对象的列表类型之上。

在我们的示例中，我们使用/
status子资源并使用客户端的UpdateStatus方法更新CR的状态（请参见\`\`Status
subresource\'\'）。 有些CR实例没有状态或没有规格状态拆分。
在这种情况下，以下标记可避免生成该UpdateStatus（）方法：

> *// +genclient:noStatus*

###### 警告

没有此标签，client-gen将盲目生成UpdateStatus（）方法。
但是，重要的是要了解，仅当在CustomResourceDefinition清单中实际启用了/
status子资源时，spec-status拆分才起作用（请参阅\`\`
subresource\'\'\'\'）。

客户端中仅存在该方法无效。 没有更改清单的请求甚至将失败。

客户端生成器必须选择正确的HTTP路径（带或不带名称空间）。
对于群集范围的资源，必须使用标签：

> *// +genclient:nonNamespaced*

默认是生成一个命名空间的客户端。 同样，这必须匹配CRD清单中的范围设置。
对于特殊用途的客户端，您可能还希望详细控制所提供的HTTP方法。
您可以通过使用几个标签来做到这一点，例如：

> *// +genclient:noVerbs*
>
> *// +genclient:onlyVerbs=create,delete*
>
> *// +genclient:skipVerbs=get,list,create,update,patch,delete,watch*
>
> *// +genclient:method=Create,verb=create,*
>
> *// result=k8s.io/apimachinery/pkg/apis/meta/v1.Status*

前三个应该是不言自明的，但是最后一个值得解释。

上面写的这个标签的类型将是仅创建的，并且不会返回API类型本身，而是一个metaav1.Status。
对于CR来说，这没有多大意义，但是对于用Go编写的用户提供的API服务器（请参阅第8章），这些资源可以存在并且在实践中确实存在。

// genclient：method =tag的一种常见情况是添加了一种扩展资源的方法。
在\`\` Scale subresource\'\'中，我们描述了如何为CR启用/
scale subresource。以下标记创建相应的客户端方法：

> *// +genclient:method=GetScale,verb=get,subresource=scale,\\*
>
> *// result=k8s.io/api/autoscaling/v1.Scale*
>
> *// +genclient:method=UpdateScale,verb=update,subresource=scale,\\*
>
> *//
> input=k8s.io/api/autoscaling/v1.Scale,result=k8s.io/api/autoscaling/v1.Scale*

第一个标签创建getter GetScale。 第二个创建setter UpdateScale。

###### 注意

所有CR / scale子资源都从autoscaling / v1组接收和输出Scale类型。
在Kubernetes API中，出于历史原因，存在使用其他类型的资源。

informer-gen and lister-gen
---------------------------

 informer-gen和 lister-gen 代都处理client-gen的//
client标记。没有其他配置。选择加入客户端生成的每种类型都会自动获得与客户端匹配的通知者和列表者（如果通过k8s.io/code-generator/generate-group.sh脚本调用整个生成器套件）。

Kubernetes生成器的文档有很大的改进空间，并且随着时间的推移当然会慢慢完善。有关不同生成器的更多信息，查看Kubernetes本身的示例通常会很有帮助-例如k8s.io/api和OpenShift
API类型。这两个存储库都有许多高级用例。

此外，不要犹豫，看看generators本身。
deepcopy-gen在其main.go文件中提供了一些文档。
client-gen在Kubernetes贡献者文档中提供了一些文档。
notifyer-gen和lister-gen当前没有进一步的文档，但是generate-groups.sh显示了如何调用它们。

摘要
====

在本章中，我们向您展示了如何为CR使用Kubernetes代码生成器。
通过这种方式，我们现在继续使用更高级别的抽象工具，即用于编写自定义控制器和运算符的解决方案，使您能够专注于业务逻辑。

1\`\`Go工具在需要时不会自动运行生成，并且缺少定义源文件和生成文件之间的依赖关系的方法
